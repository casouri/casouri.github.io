<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Notes</title>
  <link href="https://archive.casouri.cc/note" rel="self" />
  <updated>2023-08-17T22:29:00.00-05:00</updated>
  <author>
    <name>Yuan Fu</name>
  </author>
  <icon>https://archive.casouri.cc/favicon.png</icon>
  <id>urn:uuid:53fd03d4-ec1b-11eb-8cca-e7401fdbc2e2</id>
  
  
  <entry><title>Remap modifiers in Linux Desktop and Alacritty</title><link href="https://archive.casouri.cc/note/2023/alacritty-modifier"/><id>urn:uuid:19af9006-b4d9-11ed-aec6-9fe7ebf47538</id><updated>2023-02-24T22:53:00.00-05:00</updated><content type="html">&lt;p&gt;I’m used to macOS’s key binding, that means for a desktop environment, I want three things:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Caps lock act as Control&lt;/li&gt;&lt;li&gt;System bindings are on the Command key (ie, the Windows key), specifically, Command+C/V for copy/paste&lt;/li&gt;&lt;li&gt;In the terminal emulator, Command+C/V works as usual, and Ctrl+C/V sends respective control codes, as usual&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;I’m a simple man, and this is all I want, but Thy Voice From Above hath spoken: &lt;em&gt;“thy shall not have comfort, well at least not so easily, ya know?”&lt;/em&gt;&lt;/p&gt;&lt;h2 id="Command+C/V%20for%20copy%20and%20paste" class="section"&gt;Command+C/V for copy and paste&lt;/h2&gt;&lt;p&gt;Remapping Caps lock to Control is easy and there are plenty tutorials online for it. However, there is &lt;em&gt;absolutely no way&lt;/em&gt; to change the default bindings of copy/paste on a Linux desktop reliably. Because there is simply no unified configuration for the keybinding of copy &amp;amp; paste. Qt supports rebinding copy &amp;amp; paste and Gtk straight up &lt;a id="footref:gtk" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Agtk"&gt;doesn’t support it&lt;sup class="inline-footref"&gt;1&lt;/sup&gt;&lt;/a&gt;. On top of that, applications bind their own keys and completely disregard the toolkit’s setting, except in some toolkit widgets they use, then you have different bindings within the same application.&lt;/p&gt;&lt;div id="footdef:gtk" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Agtk"&gt;1&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;Gtk 3 seems to support it through CSS themes, which is removed in Gtk 4. Anyway, I never got it to work.&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The whole situation is pretty laughable, but live must go on. There are things like &lt;a id="footref:xkeysnail" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Axkeysnail"&gt;xkeysnail&lt;sup class="inline-footref"&gt;2&lt;/sup&gt;&lt;/a&gt; that literally intercepts every keystroke you type and translate them into other keys depending on the application currently in focus. It requires some nontrivial configuration and may or may not work reliably on X11, &lt;a id="footref:wayland" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Awayland"&gt;definitely doesn’t work on Wayland&lt;sup class="inline-footref"&gt;3&lt;/sup&gt;&lt;/a&gt;, and I don’t know how do I feel about a Python program running as root, intercepting and translating every key I type. There are Rust alternatives, but I didn’t have much luck with those either.&lt;/p&gt;&lt;div id="footdef:xkeysnail" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Axkeysnail"&gt;2&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;&lt;a href="https://archive.casouri.cc/note/2023/alacritty-modifier/https:/github.com/mooz/xkeysnail"&gt;xkeysnail&lt;/a&gt;. There are also projects like &lt;a href="https://archive.casouri.cc/note/2023/alacritty-modifier/https:/github.com/rbreaves/kinto"&gt;kinto.sh&lt;/a&gt; that pre-configures it for you on both Linux and Windows. (On Windows it uses AutoHotkey.)&lt;/div&gt;&lt;/div&gt;&lt;div id="footdef:wayland" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Awayland"&gt;3&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;These type of program use X11 protocol, and Wayland just doesn’t support program intercepting and translating other program’s input.&lt;/div&gt;&lt;/div&gt;&lt;p&gt;The real way, the only good way, to do it is to just swap Control with Super (ie, Command) at X11 level. (Wayland picks it up so it works on Wayland too, or so I’m told). Since we also want to swap Caps lock and Control, we actually do a three-way swap:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Super → Control&lt;/li&gt;&lt;li&gt;Control → Caps lock&lt;/li&gt;&lt;li&gt;Caps lock → Super&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;So now when you press Command+C, the application gets Control+C.&lt;/p&gt;&lt;p&gt;To actually swap the modifiers, we edit&lt;/p&gt;&lt;p&gt;&lt;span class="mono"&gt;/usr/share/X11/xkb/keycodes/evdev&lt;/span&gt;&lt;/p&gt;&lt;p&gt;and reboot—no adding command to X init or some config file or some other crap. You edit the file, reboot, and it works, and keeps working. I learned this from a &lt;a href="https://archive.casouri.cc/note/2023/alacritty-modifier/https:/askubuntu.com/questions/929744/how-to-remap-key-in-ubuntu-17-10-wayland-up-key-to-shift"&gt;StackExchange question&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Below are the exact edit you need to make in that file, and their effect:&lt;/p&gt;&lt;p&gt;To map Left Control (keycode 37) to Caps lock:&lt;br/&gt;Change &lt;code&gt;&amp;lt;CAPS&amp;gt; = 66&lt;/code&gt; to &lt;code&gt;&amp;lt;CAPS&amp;gt; = 37&lt;/code&gt;&lt;/p&gt;&lt;p&gt;To map Left Super (keycode 133) to Control:&lt;br/&gt;Change &lt;code&gt;&amp;lt;LCTL&amp;gt; = 37&lt;/code&gt; to &lt;code&gt;&amp;lt;LCTL&amp;gt; 133&lt;/code&gt;&lt;/p&gt;&lt;p&gt;To map Caps lock (keycode 66) to Left Super:&lt;br/&gt;Change &lt;code&gt;&amp;lt;LWIN&amp;gt; = 133&lt;/code&gt; to &lt;code&gt;&amp;lt;LWIN&amp;gt; = 66&lt;/code&gt;&lt;/p&gt;&lt;p&gt;If you use Emacs, you need to swap Super and Control back. Add this to your &lt;span class="mono"&gt;init.el&lt;/span&gt;:&lt;/p&gt;&lt;pre class="code-block"&gt;(setq x-super-keysym 'ctrl)
(setq x-ctrl-keysym 'super)&lt;/pre&gt;&lt;h2 id="Command+C/V%20in%20terminal" class="section"&gt;Command+C/V in terminal&lt;/h2&gt;&lt;p&gt;Now Command+C/V works in normal applications, but in terminal, Caps lock+C/V (appears as Super+C/V) will not send control keys and Command+C/V (appears as Control+C/V) will not do what you want—again, you need to swap Super and Control back, as we did for Emacs.&lt;/p&gt;&lt;p&gt;I looked at every terminal emulator on Linux, and &lt;a href="https://archive.casouri.cc/note/2023/alacritty-modifier/https:/github.com/alacritty/alacritty"&gt;Alacritty&lt;/a&gt; is the only one that allows remapping modifier keys, has sane configuration so that I can actually configure the remap, and has sane dependencies.&lt;/p&gt;&lt;p&gt;You want to remap all Control+&lt;em&gt;x&lt;/em&gt; keys to simply &lt;em&gt;x&lt;/em&gt;, except for Control+C/V/F, etc, which are bind to actions like Copy, Paste, SearchForward. And you want to remap all Super+&lt;em&gt;x&lt;/em&gt; keys to Control+&lt;em&gt;x&lt;/em&gt;. In effect, you have:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Command+C/V → Control+C/V → Copy/Paste&lt;/li&gt;&lt;li&gt;Caps lock+C/V → Super+C/V → Control+C/V&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;To do that, add this to the beginning of &lt;span class="mono"&gt;~/.config/alacritty/alacritty.yml&lt;/span&gt;:&lt;/p&gt;&lt;pre class="code-block"&gt;key_bindings:
  - { key: At, mods: Control, chars: "@" }
  - { key: A, mods: Control, chars: "a" }
  - { key: B, mods: Control, chars: "b" }
  - { key: C, mods: Control, action: Copy }
  - { key: D, mods: Control, chars: "d" }
  - { key: E, mods: Control, chars: "e" }
  - { key: F, mods: Control, action: SearchForward }
  - { key: F, mods: Control, mode: ~Search, action: SearchForward }
  - { key: F, mods: Control|Shift, action: SearchBackward }
  - { key: F, mods: Control|Shift, mode: ~Search, action: SearchBackward }
  - { key: G, mods: Control, chars: "g" }
  - { key: H, mods: Control, chars: "h" }
  - { key: I, mods: Control, chars: "i" }
  - { key: J, mods: Control, chars: "j" }
  - { key: K, mods: Control, chars: "k" }
  - { key: L, mods: Control, chars: "l" }
  - { key: M, mods: Control, chars: "m" }
  - { key: N, mods: Control, action: CreateNewWindow }
  - { key: O, mods: Control, chars: "o" }
  - { key: P, mods: Control, chars: "p" }
  - { key: Q, mods: Control, action: Quit }
  - { key: R, mods: Control, chars: "r" }
  - { key: S, mods: Control, chars: "s" }
  - { key: T, mods: Control, chars: "t" }
  - { key: U, mods: Control, chars: "u" }
  - { key: V, mods: Control, action: Paste }
  - { key: W, mods: Control, action: Quit }
  - { key: X, mods: Control, chars: Cut }
  - { key: Y, mods: Control, chars: "y" }
  - { key: Z, mods: Control, chars: "z" }
  - { key: LBracket, mods: Control, chars: "[" }
  - { key: Backslash, mods: Control, chars: "\\" }
  - { key: RBracket, mods: Control, chars: "]" }
  - { key: Grave, mods: Control, chars: "^" }
  - { key: Underline, mods: Control, chars: "_" }

  - { key: At, mods: Super, chars: "\x00" }
  - { key: A, mods: Super, chars: "\x01" }
  - { key: B, mods: Super, chars: "\x02" }
  - { key: C, mods: Super, chars: "\x03" }
  - { key: D, mods: Super, chars: "\x04" }
  - { key: E, mods: Super, chars: "\x05" }
  - { key: F, mods: Super, chars: "\x06" }
  - { key: G, mods: Super, chars: "\x07" }
  - { key: H, mods: Super, chars: "\x08" }
  - { key: I, mods: Super, chars: "\x09" }
  - { key: J, mods: Super, chars: "\x0a" }
  - { key: K, mods: Super, chars: "\x0b" }
  - { key: L, mods: Super, chars: "\x0c" }
  - { key: M, mods: Super, chars: "\x0d" }
  - { key: N, mods: Super, chars: "\x0e" }
  - { key: O, mods: Super, chars: "\x0f" }
  - { key: P, mods: Super, chars: "\x10" }
  - { key: Q, mods: Super, chars: "\x11" }
  - { key: R, mods: Super, chars: "\x12" }
  - { key: S, mods: Super, chars: "\x13" }
  - { key: T, mods: Super, chars: "\x14" }
  - { key: U, mods: Super, chars: "\x15" }
  - { key: V, mods: Super, chars: "\x16" }
  - { key: W, mods: Super, chars: "\x17" }
  - { key: X, mods: Super, chars: "\x18" }
  - { key: Y, mods: Super, chars: "\x19" }
  - { key: Z, mods: Super, chars: "\x1a" }
  - { key: LBracket, mods: Super, chars: "\x1b" }
  - { key: Backslash, mods: Super, chars: "\x1c" }
  - { key: RBracket, mods: Super, chars: "\x1d" }
  - { key: Grave, mods: Super, chars: "\x1e" }
  - { key: Underline, mods: Super, chars: "\x1f" }&lt;/pre&gt;&lt;p&gt;This configuration remaps &lt;a id="footref:ascii" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Aascii"&gt;all possible modifier keybindings available in a terminal environment&lt;sup class="inline-footref"&gt;4&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;&lt;div id="footdef:ascii" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Aascii"&gt;4&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;See this &lt;a href="https://archive.casouri.cc/note/2023/alacritty-modifier/https:/www.physics.udel.edu/~watson/scen103/ascii.html"&gt;ASCII table&lt;/a&gt;.&lt;/div&gt;&lt;/div&gt;&lt;h2 id="Conclusion" class="section"&gt;Conclusion&lt;/h2&gt;&lt;p&gt;At this point you should be able to copy &amp;amp; paste with Command+C/V in every application and terminal, and use Caps lock as Control in Emacs and terminal, &lt;em&gt;as it should be&lt;/em&gt;.&lt;/p&gt;</content></entry>
  <entry><title>Bonjour Crash Course</title><link href="https://archive.casouri.cc/note/2023/bonjour"/><id>urn:uuid:4a6f4716-b355-11ed-8033-5f84d0436494</id><updated>2023-02-23T00:37:00.00-05:00</updated><content type="html">&lt;p&gt;Bonjour is Apple’s implementation of zeroconf networking. With Bonjour, you can plug in a printer into the local network and expect it to show up on computers in the network, without manually configuring anything. Linux’s implementation is Avahi.&lt;/p&gt;&lt;p&gt;I recently needed to use Bonjour for some project and read some documentation. This is an article summarizing some concepts one needs to know in order to use a Bonjour library. This article assumes some basic network knowledge (TPC/IP, DHCP, DNS, multicast, unicast, network layers, etc).&lt;/p&gt;&lt;p&gt;Everything in this article is based on Apple’s documentation at &lt;a href="https://archive.casouri.cc/note/2023/bonjour/https:/developer.apple.com/library/archive/documentation/Cocoa/Conceptual/NetServices/Introduction.html#%2F%2Fapple_ref%2Fdoc%2Fuid%2FTP40002445-SW1"&gt;&lt;em&gt;Bonjour Overview&lt;/em&gt;&lt;/a&gt;. (If you want to read it, I recommend starting with the “Bonjour Operations” section.)&lt;/p&gt;&lt;p&gt;Bonjour operates in the link-local network and provides three operations:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Registering services&lt;/li&gt;&lt;li&gt;Discovering available services&lt;/li&gt;&lt;li&gt;Resolving a service instance name to an address and port&lt;/li&gt;&lt;/ol&gt;&lt;h2 id="Registering%20a%20service" class="section"&gt;Registering a service&lt;/h2&gt;&lt;p&gt;When registering/publishing a service, you (or rather the library) creates a mDNS (multicast DNS) responder with three records: a service (SRV) record, a pointer (PTR) record, and a text (TXT) record. The text record is for providing additional information and is usually empty.&lt;/p&gt;&lt;h3 id="Service%20records" class="subsection"&gt;Service records&lt;/h3&gt;&lt;p&gt;A service record maps the service name to the host name and the port of the service. It uses host name rather than an IP address so that the service can be on multiple IP addresses at the same time (eg, on both IPv4 and IPv6).&lt;/p&gt;&lt;p&gt;The full name of a service is made of three parts, the &lt;em&gt;service instance name&lt;/em&gt;, the &lt;em&gt;service type&lt;/em&gt;, and the &lt;em&gt;domain&lt;/em&gt;, in the form of:&lt;/p&gt;&lt;pre class="code-block"&gt;&amp;lt;service instance name&amp;gt;.&amp;lt;service type&amp;gt;.&amp;lt;domain&amp;gt;&lt;/pre&gt;&lt;p&gt;The &lt;em&gt;service instance name&lt;/em&gt; is a human-readable string showed to end-users, encoded in &lt;span class="oldstyle-num"&gt;utf-8&lt;/span&gt;, and can be up to &lt;span class="oldstyle-num"&gt;63&lt;/span&gt; bytes long.&lt;/p&gt;&lt;p&gt;The &lt;em&gt;service type&lt;/em&gt; is made of the &lt;em&gt;service type&lt;/em&gt; and the &lt;em&gt;transport protocol&lt;/em&gt;, in the form of &lt;code&gt;_type._protocol.&lt;/code&gt;. Eg, &lt;code&gt;_ftp._tcp.&lt;/code&gt;. The underscore prefix is to distinguish from domain names. Bonjour basically uses the format described in &lt;a href="https://archive.casouri.cc/note/2023/bonjour/https:/www.ietf.org/rfc/rfc2782.txt"&gt;&lt;span class="oldstyle-num"&gt;RFC 2782&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Technically, both the type and the protocol are standardized. If you want to add a service type, you need to register it with &lt;a href="https://archive.casouri.cc/note/2023/bonjour/https:/www.iana.org/form/ports-services"&gt;IANA&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The &lt;em&gt;domain name&lt;/em&gt; is just like an Internet domain name, eg, &lt;code&gt;www.apple.com.&lt;/code&gt;. In addition, there is a pseudo domain, &lt;code&gt;local.&lt;/code&gt;, which refers to the link-local network. (So you have Bonjour to thank when you ssh to LAN hosts with &lt;code&gt;&amp;lt;host&amp;gt;.local&lt;/code&gt;.)&lt;/p&gt;&lt;p&gt;Service instance name, service type, and domain name together make up the full name of a service instance. For example,&lt;/p&gt;&lt;pre class="code-block"&gt;Alice’s Music library._music._tcp.local.&lt;/pre&gt;&lt;h3 id="Pointer%20records" class="subsection"&gt;Pointer records&lt;/h3&gt;&lt;p&gt;A pointer record basically maps service types to full service names. Ie, it maps&lt;/p&gt;&lt;pre class="code-block"&gt;&amp;lt;service type&amp;gt;.&amp;lt;domain&amp;gt;&lt;/pre&gt;&lt;p&gt;to&lt;/p&gt;&lt;pre class="code-block"&gt;&amp;lt;service instance name&amp;gt;.&amp;lt;service type&amp;gt;.&amp;lt;domain&amp;gt;&lt;/pre&gt;&lt;p&gt;This way you can search for a type of service and get a list of available service instances.&lt;/p&gt;&lt;h3 id="Publishing%20(advertising)" class="subsection"&gt;Publishing (advertising)&lt;/h3&gt;&lt;p&gt;When publishing a service, a host will first make sure the intended service instance name is not taken by someone else, by broadcasting request to that service instance name: if there is a response, the name is taken. If someone else has taken it, the host will append a number to the service instance name and increment the number until it gets a name that no one is using.&lt;/p&gt;&lt;p&gt;If you use a library, this part is taken care for you. But it’s good to know how does Bonjour avoid name conflicts.&lt;/p&gt;&lt;h2 id="Discovering%20services" class="section"&gt;Discovering services&lt;/h2&gt;&lt;p&gt;To discover service instances, you first request PTR records by mDNS, and get back a list of service instance names. …And that’s it. The host will save those names, and resolve a service name into actual address and port every time it needs to use the service.&lt;/p&gt;&lt;h2 id="Resolving%20service%20names" class="section"&gt;Resolving service names&lt;/h2&gt;&lt;p&gt;By the discovery step, we collected some service instance names that are available for us in the local network. The next step is to pick one, resolve it into an actual address and connect to it.&lt;/p&gt;&lt;p&gt;The host will send out a mDNS request for the service instance name, and get back a host name and a port. It then sends out a mDNS request for the host name and get an IP address. Now it can connect to the address on the port and start using the service.&lt;/p&gt;</content></entry>
  <entry><title>Tree-sitter Starter Guide</title><link href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide"/><id>urn:uuid:afb76ba2-8a39-11ed-998c-8f06c8e638dc</id><updated>2023-01-15T00:00:00.00-05:00</updated><content type="html">&lt;p&gt;This guide gives you a starting point on writing a tree-sitter major mode. Remember, don’t panic and check your manuals!&lt;/p&gt;&lt;h2 id="Build%20Emacs%20with%20tree-sitter" class="section"&gt;Build Emacs with tree-sitter&lt;/h2&gt;&lt;p&gt;You can either install tree-sitter by your package manager, or from&lt;br/&gt;source:&lt;/p&gt;&lt;pre class="code-block"&gt;git clone https://github.com/tree-sitter/tree-sitter.git
cd tree-sitter
make
make install&lt;/pre&gt;&lt;p&gt;To build and run Emacs 29:&lt;/p&gt;&lt;pre class="code-block"&gt;git clone https://git.savannah.gnu.org/git/emacs.git -b emacs-29
cd emacs
./autogen.sh
./configure
make
src/emacs&lt;/pre&gt;&lt;p&gt;Require the tree-sitter package with &lt;code&gt;(require 'treesit)&lt;/code&gt;. Note that tree-sitter always appear as &lt;code&gt;treesit&lt;/code&gt; in symbols. Now check if Emacs is successfully built with tree-sitter library by evaluating &lt;code&gt;(treesit-available-p)&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Tree-sitter stuff in Emacs can be categorized into two parts: the tree-sitter API itself, and integration with fontification, indentation, Imenu, etc. You can use shortdoc to glance over all the tree-sitter API functions by typing &lt;code&gt;M-x shortdoc RET treesit RET&lt;/code&gt;. The integration are described in the rest of the post.&lt;/p&gt;&lt;h2 id="Install%20language%20definitions" class="section"&gt;Install language definitions&lt;/h2&gt;&lt;p&gt;Tree-sitter by itself doesn’t know how to parse any particular language. It needs the language grammar (a dynamic library) for a language to be able to parse it.&lt;/p&gt;&lt;p&gt;First, find the repository for the language grammar, eg, &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/https:/github.com/tree-sitter/tree-sitter-python"&gt;tree-sitter-python&lt;/a&gt;. Take note of the Git clone URL of it, eg, &lt;code&gt;https://github.com/tree-sitter/tree-sitter-python.git&lt;/code&gt;. Now check where is the parser.c file in that repository, usually it’s in &lt;code&gt;src&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Make sure you have Git, C and C++ compiler, and run the &lt;code&gt;treesit-install-grammar&lt;/code&gt; command, it will prompt for the URL and the directory of parser.c, leave other prompts at default unless you know what you are doing.&lt;/p&gt;&lt;p&gt;You can also manually clone the repository and compile it, and put the dynamic library at a standard library location. Emacs will be able to find it. If you wish to put it somewhere else, set &lt;code&gt;treesit-extra-load-path&lt;/code&gt; so Emacs can find it.&lt;/p&gt;&lt;h2 id="Tree-sitter%20major%20modes" class="section"&gt;Tree-sitter major modes&lt;/h2&gt;&lt;p&gt;Tree-sitter modes should be separate major modes, usually named &lt;code&gt;xxx-ts-mode&lt;/code&gt;. I know I said tree-sitter always appear as &lt;code&gt;treesit&lt;/code&gt; in symbols, this is the only exception.&lt;/p&gt;&lt;p&gt;If the tree-sitter mode and the “native” mode could share some setup code, you can create a “base mode”, which only contains the common setup.  For example, there is python-base-mode (shared), and both python-mode (native), and python-ts-mode (tree-sitter) derives from it.&lt;/p&gt;&lt;p&gt;In the tree-sitter mode, check if we can use tree-sitter with &lt;code&gt;treesit-ready-p&lt;/code&gt;, it will emit a warning if tree-sitter is not ready (tree-sitter not built with Emacs, can’t find the language grammar, buffer too large, etc).&lt;/p&gt;&lt;h2 id="Fontification" class="section"&gt;Fontification&lt;/h2&gt;&lt;p&gt;Tree-sitter works like this: It parses the buffer and produces a &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/https:/en.wikipedia.org/wiki/Parse_tree"&gt;&lt;em&gt;parse tree&lt;/em&gt;&lt;/a&gt;. You provide a query made of patterns and capture names, tree-sitter finds the nodes that match these patterns, tag the corresponding capture names onto the nodes and return them to you. The query function returns a list of &lt;code&gt;(capture-name . node)&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;For fontification, we simply use face names as capture names. And the captured node will be fontified in their capture name (the face).&lt;/p&gt;&lt;p&gt;The capture name could also be a function, in which case &lt;code&gt;(NODE OVERRIDE START END)&lt;/code&gt; is passed to the function for fontification. &lt;code&gt;START&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; are the start and end of the region to be fontified.  The function should only fontify within that region.  The function should also allow more optional arguments with &lt;code&gt;&amp;amp;rest _&lt;/code&gt;, for future extensibility.  For &lt;code&gt;OVERRIDE&lt;/code&gt; check out the docstring of &lt;code&gt;treesit-font-lock-rules&lt;/code&gt;.&lt;/p&gt;&lt;h3 id="Query%20syntax" class="subsection"&gt;Query syntax&lt;/h3&gt;&lt;p&gt;There are two types of nodes: “named nodes”, like &lt;code&gt;(identifier)&lt;/code&gt;, &lt;code&gt;(function_definition)&lt;/code&gt;, and “anonymous nodes”, like &lt;code&gt;"return"&lt;/code&gt;, &lt;code&gt;"def"&lt;/code&gt;, &lt;code&gt;"("&lt;/code&gt;, &lt;code&gt;";"&lt;/code&gt;. Parent-child relationship is expressed as&lt;/p&gt;&lt;pre class="code-block"&gt;(parent (child) (child) (child (grand_child)))&lt;/pre&gt;&lt;p&gt;Eg, an argument list &lt;code&gt;(1, "3", 1)&lt;/code&gt; would be:&lt;/p&gt;&lt;pre class="code-block"&gt;(argument_list "(" (number) (string) (number) ")")&lt;/pre&gt;&lt;p&gt;Children could have field names:&lt;/p&gt;&lt;pre class="code-block"&gt;(function_definition name: (identifier) type: (identifier))&lt;/pre&gt;&lt;p&gt;To match any one in the list:&lt;/p&gt;&lt;pre class="code-block"&gt;["true" "false" "none"]&lt;/pre&gt;&lt;p&gt;Capture names can come after any node in the pattern:&lt;/p&gt;&lt;pre class="code-block"&gt;(parent (child) @child) @parent&lt;/pre&gt;&lt;p&gt;The query above captures both the parent and the child.&lt;/p&gt;&lt;p&gt;The query below captures all the keywords with capture name&lt;br/&gt;&lt;code&gt;"keyword"&lt;/code&gt;:&lt;/p&gt;&lt;pre class="code-block"&gt;["return" "continue" "break"] @keyword&lt;/pre&gt;&lt;p&gt;These are the common syntax, check out the full syntax in the manual: &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/html-manual/Pattern-Matching.html"&gt;Pattern Matching&lt;/a&gt;.&lt;/p&gt;&lt;h3 id="Query%20references" class="subsection"&gt;Query references&lt;/h3&gt;&lt;p&gt;But how do one come up with the queries? Take python for an example, open any python source file, type &lt;code&gt;M-x treesit-explore-mode RET&lt;/code&gt;.  You should see the parse tree in a separate window, automatically updated as you select text or edit the buffer.  Besides this, you can consult the grammar of the language definition. For example, Python’s grammar file is at&lt;/p&gt;&lt;p&gt;&lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/https:/github.com/tree-sitter/tree-sitter-python/blob/master/grammar.js"&gt;https://github.com/tree-sitter/tree-sitter-python/blob/master/grammar.js&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Neovim also has a bunch of &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/https:/github.com/nvim-treesitter/nvim-treesitter/tree/master/queries"&gt;queries to reference from&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The manual explains how to read grammar files in the bottom of &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/html-manual/Language-Grammar.html"&gt;Language Grammar&lt;/a&gt;.&lt;/p&gt;&lt;h3 id="Debugging%20queries" class="subsection"&gt;Debugging queries&lt;/h3&gt;&lt;p&gt;If your query has problems, use &lt;code&gt;treesit-query-validate&lt;/code&gt; to debug the query. It will pop a buffer containing the query (in text format) and mark the offending part in red. Set &lt;code&gt;treesit--font-lock-verbose&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; if you want the font-lock function to report what it’s doing.&lt;/p&gt;&lt;h3 id="Set%20up%20font-lock" class="subsection"&gt;Set up font-lock&lt;/h3&gt;&lt;p&gt;To enable tree-sitter font-lock, set &lt;code&gt;treesit-font-lock-settings&lt;/code&gt; and &lt;code&gt;treesit-font-lock-feature-list&lt;/code&gt; buffer-locally and call &lt;code&gt;treesit-major-mode-setup&lt;/code&gt;. For example, see &lt;code&gt;python--treesit-settings&lt;/code&gt; in python.el. Below is a snippet of it.&lt;/p&gt;&lt;p&gt;Note that like the current font-lock system, if the to-be-fontified region already has a face (ie, an earlier match fontified part/all of the region), the new face is discarded rather than applied. If you want later matches always override earlier matches, use the &lt;code&gt;:override&lt;/code&gt; keyword.&lt;/p&gt;&lt;p&gt;Each rule should have a &lt;code&gt;:feature&lt;/code&gt;, like &lt;code&gt;function-name&lt;/code&gt;, &lt;code&gt;string-interpolation&lt;/code&gt;, &lt;code&gt;builtin&lt;/code&gt;, etc. This way users can enable/disable each feature individually.&lt;/p&gt;&lt;p&gt;Read the manual section &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/html-manual/Parser_002dbased-Font-Lock.html"&gt;Parser-based Font-Lock&lt;/a&gt; for more detail.&lt;/p&gt;&lt;p&gt;Example from python.el:&lt;/p&gt;&lt;pre class="code-block"&gt;(defvar python--treesit-settings
  (treesit-font-lock-rules
   :feature 'comment
   :language 'python
   '((comment) @font-lock-comment-face)

   :feature 'string
   :language 'python
   '((string) @python--treesit-fontify-string)

   :feature 'string-interpolation
   :language 'python
   :override t
   '((interpolation (identifier) @font-lock-variable-name-face))

   ...))&lt;/pre&gt;&lt;p&gt;In &lt;code&gt;python-ts-mode&lt;/code&gt;:&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-parser-create 'python)
(setq-local treesit-font-lock-settings python--treesit-settings)
(setq-local treesit-font-lock-feature-list
                '(( comment definition)
                  ( keyword string type)
                  ( assignment builtin constant decorator
                    escape-sequence number property string-interpolation )
                  ( bracket delimiter function operator variable)))
...
(treesit-major-mode-setup)&lt;/pre&gt;&lt;p&gt;Concretely, something like this:&lt;/p&gt;&lt;pre class="code-block"&gt;(define-derived-mode python-ts-mode python-base-mode "Python"
  "Major mode for editing Python files, using tree-sitter library.

\\{python-ts-mode-map}"
  :syntax-table python-mode-syntax-table
  (when (treesit-ready-p 'python)
    (treesit-parser-create 'python)
    (setq-local treesit-font-lock-feature-list
                '(( comment definition)
                  ( keyword string type)
                  ( assignment builtin constant decorator
                    escape-sequence number property string-interpolation )
                  ( bracket delimiter function operator variable)))
    (setq-local treesit-font-lock-settings python--treesit-settings)
    (setq-local imenu-create-index-function
                #'python-imenu-treesit-create-index)
    (setq-local treesit-defun-type-regexp (rx (or "function" "class")
                                              "_definition"))
    (setq-local treesit-defun-name-function
                #'python--treesit-defun-name)
    (treesit-major-mode-setup)

    (when python-indent-guess-indent-offset
      (python-indent-guess-indent-offset))))&lt;/pre&gt;&lt;h2 id="Indentation" class="section"&gt;Indentation&lt;/h2&gt;&lt;p&gt;Indentation works like this: We have a bunch of rules that look like&lt;/p&gt;&lt;pre class="code-block"&gt;(MATCHER ANCHOR OFFSET)&lt;/pre&gt;&lt;p&gt;When the indenting a line, let &lt;code&gt;NODE&lt;/code&gt; be the node at the beginning of the current line, we pass this node to the &lt;code&gt;MATCHER&lt;/code&gt; of each rule, one of them will match the node (eg, “this node is a closing bracket!”). Then we pass the node to the &lt;code&gt;ANCHOR&lt;/code&gt;, which returns a point (eg, the beginning of &lt;code&gt;NODE&lt;/code&gt;’s parent). We find the column number of that point (eg, 4), add &lt;code&gt;OFFSET&lt;/code&gt; to it (eg, 0), and that is the column we want to indent the current line to (4 + 0 = 4).&lt;/p&gt;&lt;p&gt;Matchers and anchors are functions that takes &lt;code&gt;(NODE PARENT BOL &amp;amp;rest _)&lt;/code&gt;. Matches return nil/non-nil for no match/match, and anchors return the anchor point. An Offset is usually a number or a variable, but it can also be a function. Below are some convenient builtin matchers and anchors.&lt;/p&gt;&lt;p&gt;For &lt;code&gt;MATHCER&lt;/code&gt; we have&lt;/p&gt;&lt;pre class="code-block"&gt;(parent-is TYPE) =&amp;gt; matches if PARENT’s type matches TYPE as regexp
(node-is TYPE) =&amp;gt; matches NODE’s type
(query QUERY) =&amp;gt; matches if querying PARENT with QUERY
                 captures NODE.

(match NODE-TYPE PARENT-TYPE NODE-FIELD
       NODE-INDEX-MIN NODE-INDEX-MAX)

=&amp;gt; checks everything. If an argument is nil, don’t match that. Eg,
(match nil TYPE) is the same as (parent-is TYPE)&lt;/pre&gt;&lt;p&gt;For &lt;code&gt;ANCHOR&lt;/code&gt; we have&lt;/p&gt;&lt;pre class="code-block"&gt;first-sibling =&amp;gt; start of the first sibling
parent =&amp;gt; start of parent
parent-bol =&amp;gt; BOL of the line parent is on.
prev-sibling =&amp;gt; start of previous sibling
no-indent =&amp;gt; current position (don’t indent)
prev-line =&amp;gt; start of previous line&lt;/pre&gt;&lt;p&gt;There is also a manual section for indent: &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/html-manual/Parser_002dbased-Indentation.html"&gt;Parser-based Indentation&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;When writing indent rules, you can use &lt;code&gt;treesit-check-indent&lt;/code&gt; to&lt;br/&gt;check if your indentation is correct. To debug what went wrong, set&lt;br/&gt;&lt;code&gt;treesit--indent-verbose&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;. Then when you indent, Emacs&lt;br/&gt;tells you which rule is applied in the echo area.&lt;/p&gt;&lt;p&gt;Here is an example:&lt;/p&gt;&lt;pre class="code-block"&gt;(defvar typescript-mode-indent-rules
  (let ((offset 'typescript-indent-offset))
    `((typescript
       ;; This rule matches if node at point is ")", ANCHOR is the
       ;; parent node’s BOL, and offset is 0.
       ((node-is ")") parent-bol 0)
       ((node-is "]") parent-bol 0)
       ((node-is "&amp;gt;") parent-bol 0)
       ((node-is "\\.") parent-bol ,offset)
       ((parent-is "ternary_expression") parent-bol ,offset)
       ((parent-is "named_imports") parent-bol ,offset)
       ((parent-is "statement_block") parent-bol ,offset)
       ((parent-is "type_arguments") parent-bol ,offset)
       ((parent-is "variable_declarator") parent-bol ,offset)
       ((parent-is "arguments") parent-bol ,offset)
       ((parent-is "array") parent-bol ,offset)
       ((parent-is "formal_parameters") parent-bol ,offset)
       ((parent-is "template_substitution") parent-bol ,offset)
       ((parent-is "object_pattern") parent-bol ,offset)
       ((parent-is "object") parent-bol ,offset)
       ((parent-is "object_type") parent-bol ,offset)
       ((parent-is "enum_body") parent-bol ,offset)
       ((parent-is "arrow_function") parent-bol ,offset)
       ((parent-is "parenthesized_expression") parent-bol ,offset)
       ...))))&lt;/pre&gt;&lt;p&gt;Then you set &lt;code&gt;treesit-simple-indent-rules&lt;/code&gt; to your rules, and call &lt;code&gt;treesit-major-mode-setup&lt;/code&gt;.&lt;/p&gt;&lt;h2 id="Imenu" class="section"&gt;Imenu&lt;/h2&gt;&lt;p&gt;Set &lt;code&gt;treesit-simple-imenu-settings&lt;/code&gt; and call &lt;code&gt;treesit-major-mode-setup&lt;/code&gt;.&lt;/p&gt;&lt;h2 id="Navigation" class="section"&gt;Navigation&lt;/h2&gt;&lt;p&gt;Set &lt;code&gt;treesit-defun-type-regexp&lt;/code&gt;, &lt;code&gt;treesit-defun-name-function&lt;/code&gt;, and call &lt;code&gt;treesit-major-mode-setup&lt;/code&gt;.&lt;/p&gt;&lt;h2 id="C-like%20languages" class="section"&gt;C-like languages&lt;/h2&gt;&lt;p&gt;[Update: Common functions described in this section have been moved from c-ts-mode.el to c-ts-common.el. I also made some changes to the functions and variables themselves.]&lt;/p&gt;&lt;p&gt;c-ts-common.el has some goodies for handling indenting and filling block comments.&lt;/p&gt;&lt;p&gt;These two rules should take care of indenting block comments.&lt;/p&gt;&lt;pre class="code-block"&gt;((and (parent-is "comment") c-ts-common-looking-at-star)
 c-ts-common-comment-start-after-first-star -1)
((parent-is "comment") prev-adaptive-prefix 0)&lt;/pre&gt;&lt;p&gt;&lt;code&gt;standalone-parent&lt;/code&gt; should be enough for most of the cases where you want to "indent one level further", for example, a statement inside a block. Normally &lt;code&gt;standalone-parent&lt;/code&gt; returns the parent’s start position as the anchor, but if the parent doesn’t start on its own line, it returns the parent’s parent instead, and so on and so forth. This works pretty well in practice. For example, indentation rules for statements and brackets would look like:&lt;/p&gt;&lt;pre class="code-block"&gt;;; Statements in {} block.
((parent-is "compound_statement") standalone-parent x-mode-indent-offset)
;; Closing bracket.
((node-is "}") standalone-parent x-mode-indent-offset)
;; Opening bracket.
((node-is "compound_statement") standalone-parent x-mode-indent-offset)&lt;/pre&gt;&lt;p&gt;You’ll need additional rules for “brackless” if/for/while statements, eg&lt;/p&gt;&lt;pre class="code-block"&gt;if (true)
  return 0;
else
  return 1;&lt;/pre&gt;&lt;p&gt;You need rules like these:&lt;/p&gt;&lt;pre class="code-block"&gt;((parent-is "if_statement") standalone-parent x-mode-indent-offset)&lt;/pre&gt;&lt;p&gt;Finally, &lt;code&gt;c-ts-common-comment-setup&lt;/code&gt; will set up comment and filling for you.&lt;/p&gt;&lt;h2 id="Multi-language%20modes" class="section"&gt;Multi-language modes&lt;/h2&gt;&lt;p&gt;Refer to the manual: &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/html-manual/Multiple-Languages.html"&gt;Multiple Languages&lt;/a&gt;.&lt;/p&gt;&lt;h2 id="Common%20Tasks" class="section"&gt;Common Tasks&lt;/h2&gt;&lt;p&gt;&lt;code&gt;M-x shortdoc RET treesit RET&lt;/code&gt; will give you a complete list.&lt;/p&gt;&lt;p&gt;How to...&lt;/p&gt;&lt;p&gt;&lt;b&gt;Get the buffer text corresponding to a node?&lt;/b&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-node-text node)&lt;/pre&gt;&lt;p&gt;Don’t confuse this with &lt;code&gt;treesit-node-string&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;b&gt;Scan the whole tree for stuff?&lt;/b&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-search-subtree)
(treesit-search-forward)
(treesit-induce-sparse-tree)&lt;/pre&gt;&lt;p&gt;&lt;b&gt;Find/move to to next node that...?&lt;/b&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-search-forward node ...)
(treesit-search-forward-goto node ...)&lt;/pre&gt;&lt;p&gt;&lt;b&gt;Get the root node?&lt;/b&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-buffer-root-node)&lt;/pre&gt;&lt;p&gt;&lt;b&gt;Get the node at point?&lt;/b&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-node-at (point))&lt;/pre&gt;</content></entry>
  <entry><title>Tree-sitter in Emacs 29 and Beyond</title><link href="https://archive.casouri.cc/note/2023/tree-sitter-in-emacs-29"/><id>urn:uuid:fac62c4a-8599-11ed-a0db-5f97535421d3</id><updated>2023-01-15T00:00:00.00-05:00</updated><content type="html">&lt;p&gt;Emacs’ release branch is now on complete feature freeze, meaning absolutely only bug fixes can happen on it. Now is a good time to talk about the state of &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-in-emacs-29/https:/tree-sitter.github.io/tree-sitter"&gt;tree-sitter&lt;/a&gt; in Emacs: what do you get in Emacs 29, what you don’t, and what would happen going forward.&lt;/p&gt;&lt;h2 id="What%E2%80%99s%20in%20Emacs%2029" class="section"&gt;What’s in Emacs 29&lt;/h2&gt;&lt;p&gt;From a pure user’s perspective, Emacs 29 just adds some new built-in major modes which look more-or-less identical to the old ones. There aren’t any flashy cool features either. That sounds disappointing, but there are a lot of new stuff under the hood, a solid base upon which exciting things can emerge.&lt;/p&gt;&lt;p&gt;If Emacs 29 is built with the tree-sitter library, you have access to most of the functions in its C API, including creating parsers, parsing text, retrieving nodes from the parse tree, finding the parent/child/sibling node, pattern matching nodes with a DSL, etc. You also get a bunch of convenient functions built upon the primitive functions, like searching for a particular node in the parse tree, cherry picking nodes and building a sparse tree out of the parse tree, getting the node at point, etc. You can type &lt;code&gt;M-x shortdoc RET treesit RET&lt;/code&gt; to view a list of tree-sitter functions. And because it’s Emacs, there is comprehensive manual coverage for everything you need to know. It’s in “Section 37, Parsing Program Source” of Emacs Lisp Reference Manual.&lt;/p&gt;&lt;p&gt;Emacs 29 has built-in tree-sitter major modes for C, C++, C#, Java, Rust, Go, Python, Javascript, Typescript, JSON, YAML, TOML, CSS, Bash, Dockerfile, CMake file. We tried to extend existing modes with tree-sitter at first but it didn’t work out too well, so now tree-sitter lives in separate major modes. The tree-sitter modes are usually called &lt;code&gt;xxx-ts-mode&lt;/code&gt;, like &lt;code&gt;c-ts-mode&lt;/code&gt; and &lt;code&gt;python-ts-mode&lt;/code&gt;. The simplest way to enable them is to use &lt;code&gt;major-mode-remap-alist&lt;/code&gt;. For example,&lt;/p&gt;&lt;pre class="code-block"&gt;(add-to-list 'major-mode-remap-alist
             '(c-mode . c-ts-mode))&lt;/pre&gt;&lt;p&gt;The built-in tree-sitter major modes have support for font-lock (syntax highlight), indentation, Imenu, which-func, and defun navigation.&lt;/p&gt;&lt;p&gt;For major mode developers, Emacs 29 includes integration for these features for tree-sitter, so major modes only need to supply language-specific information, and Emacs takes care of plugging tree-sitter into font-lock, indent, Imenu, etc.&lt;/p&gt;&lt;h3 id="Fontification" class="subsection"&gt;Fontification&lt;/h3&gt;&lt;p&gt;In tree-sitter major modes, fontification is categorized into “features”, like “builtin”, “function”, “variable”, “operator”, etc. You can choose what “features” to enable for a mode. If you are feeling adventurous, it is also possible to add your own fontification rules.&lt;/p&gt;&lt;p&gt;To add/remove features for a major mode, use &lt;code&gt;treesit-font-lock-recompute-features&lt;/code&gt; in its mode hook. For example,&lt;/p&gt;&lt;pre class="code-block"&gt;(defun c-ts-mode-setup ()
  (treesit-font-lock-recompute-features
   '(function variable) '(definition)))

(add-hook 'c-ts-mode-hook #'c-ts-mode-setup)&lt;/pre&gt;&lt;p&gt;Features are grouped into decoration levels, right now there are 4 levels and the default level is 3. If you want to program in skittles, set &lt;code&gt;treesit-font-lock-level&lt;/code&gt; to 4 ;-)&lt;/p&gt;&lt;h3 id="Language%20grammars" class="subsection"&gt;Language grammars&lt;/h3&gt;&lt;p&gt;Tree-sitter major modes need corresponding langauge grammar to work. These grammars come in the form of dynamic libraries. Ideally the package manager will build them when building Emacs, like with any other dynamic libraries. But they can’t cover every language grammar out there, so you probably need to build them yourself from time to time. Emacs has a command for it: &lt;code&gt;treesit-install-language-grammar&lt;/code&gt;. It asks you for the Git repository and other stuff and builds the dynamic library. Third-party major modes can instruct their users to add the recipe for building a language grammar like this:&lt;/p&gt;&lt;pre class="code-block"&gt;(add-to-list
 'treesit-language-source-alist
 '(python "https://github.com/tree-sitter/tree-sitter-python.git"))&lt;/pre&gt;&lt;p&gt;Then typing &lt;code&gt;M-x treesit-install-language-grammar RET python&lt;/code&gt; builds the language grammar without user-input.&lt;/p&gt;&lt;h3 id="Other%20features" class="subsection"&gt;Other features&lt;/h3&gt;&lt;p&gt;Things like indentation, Imenu, navigation, etc, should just work.&lt;/p&gt;&lt;p&gt;There is no code-folding, selection expansion, and structural navigation (except for defun) in Emacs 29. Folding and expansion should be trivial to implement in existing third-party packages. Structural navigation needs careful design and nontrivial changes to existing commands (ie, more work). So not in 29, unfortunately.&lt;/p&gt;&lt;h2 id="Future%20plans" class="section"&gt;Future plans&lt;/h2&gt;&lt;h3 id="Navigation" class="subsection"&gt;Navigation&lt;/h3&gt;&lt;p&gt;The tree-sitter integration is far from complete. As mentioned earlier, structural navigation is still in the works. Right now Emacs allows you to define a “thing” by a regexp that matches node types, plus optionally a filter function that filters out nodes that matches the regexp but isn’t really the “thing”. Given the definition of a “thing”, Emacs has functions for finding the “things” around point (&lt;code&gt;treesit--things-around&lt;/code&gt;), finding the “thing” at point (&lt;code&gt;treesit--thing-at-point&lt;/code&gt;), and navigating around “things” (&lt;code&gt;treesit--navigate-thing&lt;/code&gt;). Besides moving around, these functions should be also useful for other things like folding blocks. Beware that, as the double dash suggests, these functions are experimental and could change.&lt;/p&gt;&lt;p&gt;I also have an idea for “abstract list elements”. Basically an abstract list element is anything repeatable in a grammar: defun, statement, arguments in argument list, etc. These things appear at every level of the grammar and seems like a very good unit for navigation.&lt;/p&gt;&lt;h3 id="Context%20extraction" class="subsection"&gt;Context extraction&lt;/h3&gt;&lt;p&gt;There is also potential for language-agnostic “context extraction” (for the lack of a better term) with tree-sitter. Right now we can get the name and span of the defun at point, but it doesn’t have to stop there, we can also get the parameter list, the type of the return value, the class/trait of the function, etc. Because it’s language agnostic, any tool using this feature will work on many languages all at once.&lt;/p&gt;&lt;p&gt;In fact, you can already extract useful things, to some degree, with the fontification queries written by major modes: using the query intended for the &lt;code&gt;variable&lt;/code&gt; query, I can get all the variable nodes in a given range.&lt;/p&gt;&lt;p&gt;There are some unanswered questions though: (1) What would be the best function interface and data structure for such a feature? Should it use a plist like &lt;code&gt;(:name ... :params ...)&lt;/code&gt;, or a cl-struct? (2) If a language is different enough from the “common pattern”, how useful does this feature remains? For example, there isn’t a clear parameter list in Haskell, and there could be several defun bodies that defines the same function. (3) Is this feature genuinely useful, or is it just something that looks cool? Only time and experiments can tell, I’m looking forward to see what people will do with tree-sitter in the wild :-)&lt;/p&gt;&lt;h3 id="Major%20mode%20fallback" class="subsection"&gt;Major mode fallback&lt;/h3&gt;&lt;p&gt;Right now there is no automatic falling back from tree-sitter major modes to “native” major modes when the tree-sitter library or language grammar is missing. Doing it right requires some change to the auto-mode facility. Hopefully we’ll see a good solution for it in Emacs 30. Right now, if you need automatic fallback, try something like this:&lt;/p&gt;&lt;pre class="code-block"&gt;(define-derived-mode python-auto-mode prog-mode "Python Auto"
  "Automatically decide which Python mode to use."
  (if (treesit-ready-p 'python t)
      (python-ts-mode)
    (python-mode)))&lt;/pre&gt;&lt;h3 id="Other%20plans" class="subsection"&gt;Other plans&lt;/h3&gt;&lt;p&gt;Existing tree-sitter major modes are pretty basic and doesn’t have many bells and whistles, and I’m sure there are rough corners here and there. Of course, these things will improve over time.&lt;/p&gt;&lt;p&gt;Tree-sitter is very different and very new, and touches many parts of Emacs, so no one has experience with it and no one knows exactly how should it look like. Emacs 29 will give us valuable experience and feedback, and we can make it better and better in the future.&lt;/p&gt;&lt;p&gt;If you are interested, get involved! Read &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-in-emacs-29/note/2020/contributing-to-emacs/index.html"&gt;Contributing to Emacs&lt;/a&gt; for some tips in getting involved with the Emacs development. Read &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-in-emacs-29/note/2023/tree-sitter-starter-guide/index.html"&gt;Tree-sitter Starter Guide&lt;/a&gt; if you want to write a major mode using tree-sitter. And of course, docstrings and the manual is always your friend. If you have questions, you can ask on Reddit, or comment in this post’s public inbox (see the footer).&lt;/p&gt;</content></entry>
  <entry><title>This Site is Changing its Domain</title><link href="https://archive.casouri.cc/note/2022/domain-change"/><id>urn:uuid:ff14d65c-6726-11ed-b927-c76ea0aa4499</id><updated>2022-11-18T00:00:00.00-05:00</updated><content type="html">&lt;p&gt;Right now this site resides on &lt;a href="https://archive.casouri.cc/note/2022/domain-change/https:/archive.casouri.cat"&gt;archive.casouri.cat&lt;/a&gt;, I really love the .cat TLD. Alas, .cat was never meant for generic use and my site doesn't comply to its requirements, which is to use and promote Catalan language and culture. I don’t want to wake up one day recieving a take down notice, however slim the possibility is. Plus, the longer this site uses this domain, the more backlinks to it, the harder to move on.&lt;/p&gt;&lt;p&gt;Moving forward, this site will be on &lt;a href="https://archive.casouri.cc/note/2022/domain-change/https:/archive.casouri.cc"&gt;archive.casouri.cc&lt;/a&gt;. I'll keep the .cat domain around for a few years. In the meantime the .cat domain will redirect to the .cc domain by 301 redirect. The whole site is archived on the Wayback Machine. Hopefully someone in the future clicking on my .cat link knows about Wayback Machine and can view the page.&lt;/p&gt;&lt;p&gt;If you have a link to the .cat domain, you might want to edit the link to point to the new domain. Sorry for the incovenience! Fortunately there are so few links to my site :-)&lt;/p&gt;</content></entry>
  <entry><title>NAT traversal: STUN, TURN, ICE, what do they actually do?</title><link href="https://archive.casouri.cc/note/2022/nat-what-do-they-do"/><id>urn:uuid:84e3d816-a8c6-11ec-bcbd-af8069bc8361</id><updated>2022-03-20T20:26:00.00-05:00</updated><content type="html">&lt;p&gt;When searching for NAT traversal I found all these protocols but no one can tell me what do they essentially do to traverse NAT, surely not by magic, but what? Turns out it’s conceptually very simple.&lt;/p&gt;&lt;p&gt;What NAT traversal does is not really “punching holes” on the NAT, or delivering message through some tunnel, or some arcane magic, but to simply find the public address:port that can can reach &lt;em&gt;me&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;If I’m behind a NAT or even multiple NAT’s, my packets are relayed by these NAT’s and they appears on the public Internet at the out-most NAT’s address and port. And reply packets going to that address:port are relayed back to me. So essentially I got a public address:port that can reach me on the public Internet. The purpose of NAT traversal is to find that public address:port. That’s basically what the initial/classic STUN (&lt;a href="https://archive.casouri.cc/note/2022/nat-what-do-they-do/https:/datatracker.ietf.org/doc/html/rfc3489"&gt;&lt;span class="oldstyle-num"&gt;RFC 3489&lt;/span&gt;&lt;/a&gt;) does.&lt;/p&gt;&lt;p&gt;The truly host-to-host traversal is just that, finding the public address:port.&lt;br/&gt;That’s what classic STUN does. You send a STUN server a message, the STUN server looks at the source IP address and port of the IP packet, and reply that back to you. Voilà, you know you public &lt;code&gt;address:port&lt;/code&gt;!&lt;/p&gt;&lt;p&gt;Sometimes having that address:port is not enough, because NAT poses &lt;a id="footref:extra" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Aextra"&gt;extra restrictions&lt;sup class="inline-footref"&gt;1&lt;/sup&gt;&lt;/a&gt;. Then we have to resort to having a public-visible relay server in the middle, which is what TURN (&lt;a href="https://archive.casouri.cc/note/2022/nat-what-do-they-do/https:/datatracker.ietf.org/doc/html/rfc5766"&gt;&lt;span class="oldstyle-num"&gt;RFC 5766&lt;/span&gt;&lt;/a&gt;) does. But any host-to-host traversal is just finding public address:port. There is no extra magic there.&lt;/p&gt;&lt;div id="footdef:extra" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Aextra"&gt;1&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;Some NAT wouldn’t let a packet from an external host through if the host inside never sent a packet to that external host before. There are many ways a NAT could make your life difficult, check out “full cone”, “restricted cone”, “symmetric NAT”, etc.&lt;/div&gt;&lt;/div&gt;&lt;p&gt;But STUNnd TURN still isn’t enough. For one, one can usually find multiple address that could possibly work, but then which one to use? Eg, maybe a host has an IP assigned by a VPN, if the other host is also in the VPN, we should use this IP over the others; similarly, if the other host is in the same LAN, we should use the local IP; even over NAT, there could be multiple IP’s that can reach us.&lt;/p&gt;&lt;p&gt;ICE fills that gap. It gathers a bunch of &lt;code&gt;address:port&lt;/code&gt;’s that possibly works (through STUN messages with stun servers), sorts them by preference, and tries them one-by-one according to some algorithm, and reports to you the best one. If none works, it tries to establish a relay through TURN.&lt;/p&gt;&lt;p&gt;And here is where the new STUN comes in. People threw away the algorithm for finding &lt;code&gt;address:port&lt;/code&gt; in classic STUN, and kept and extended the STUN message format. Now ICE runs a more thorough algorithm that uses STUN messages to communicate with STUN servers. And the new STUN (&lt;a href="https://archive.casouri.cc/note/2022/nat-what-do-they-do/https:/datatracker.ietf.org/doc/html/rfc5389"&gt;&lt;span class="oldstyle-num"&gt;RFC 5389&lt;/span&gt;&lt;/a&gt;) just defines the STUN message format. There is a even newer version (&lt;a href="https://archive.casouri.cc/note/2022/nat-what-do-they-do/https:/datatracker.ietf.org/doc/html/rfc8489"&gt;&lt;span class="oldstyle-num"&gt;RFC 8489&lt;/span&gt;&lt;/a&gt;) that updated &lt;span class="oldstyle-num"&gt;RFC 5389&lt;/span&gt; slightly, but with no fundamental changes.&lt;/p&gt;&lt;p&gt;Similarly, TURN is updated in &lt;a href="https://archive.casouri.cc/note/2022/nat-what-do-they-do/https:/datatracker.ietf.org/doc/html/rfc8656"&gt;&lt;span class="oldstyle-num"&gt;RFC 8656&lt;/span&gt;&lt;/a&gt; and now is a method used by ICE rather than a standalone solution.&lt;/p&gt;</content></entry>
  <entry><title>Using Fontsets in Emacs</title><link href="https://archive.casouri.cc/note/2021/fontset"/><id>urn:uuid:336b8c2c-4d8b-11ec-967b-17e83717b0eb</id><updated>2021-11-24T17:01:00.00-05:00</updated><content type="html">&lt;h2 id="Fontset" class="section"&gt;Fontset?&lt;/h2&gt;&lt;p&gt;Fontset is a feature of Emacs that allows you to bundle together multiple fonts and use them as a single font, such that it covers more characters than a single font could have. For example, you can combine a Latin font, a Greek font and a Chinese font together.&lt;/p&gt;&lt;p&gt;With fontsets, we can use different Unicode fonts for different faces. For example, serif Latin and Chinese font for a “serif” face, and sans serif Latin and Chinese font for a “sans” face. Without fontsets, we can only set different Latin fonts to faces and use a single fall-back Chinese font.&lt;/p&gt;&lt;p&gt;&lt;img class="half" alt="A graph showing different fonts with different faces" src="https://archive.casouri.cc/note/2021/fontset/fonts%20&amp;amp;%20faces.svg"/&gt;&lt;/p&gt;&lt;h2 id="Create%20a%20fontset" class="section"&gt;Create a fontset&lt;/h2&gt;&lt;p&gt;A fontset is recognized by its name. Each fontset has two names, one short and one long. The short name looks like &lt;code&gt;fontset-xxx&lt;/code&gt;. The long name is a &lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/wiki.archlinux.org/title/X_Logical_Font_Description"&gt;X Logical Font Description&lt;/a&gt; with last two fields being &lt;code&gt;fontset&lt;/code&gt; and &lt;code&gt;xxx&lt;/code&gt;. For example,&lt;/p&gt;&lt;pre class="code-block"&gt;-*-ibm plex mono-medium-*-*-*-13-*-*-*-*-*-fontset-my fontset&lt;/pre&gt;&lt;p&gt;Emacs come with three fontsets by default: &lt;code&gt;fontset-startup&lt;/code&gt;, &lt;code&gt;fontset-standard&lt;/code&gt; and &lt;code&gt;fontset-default&lt;/code&gt;. We only care about &lt;code&gt;fontset-default&lt;/code&gt;; it is the ultimate fall-back when Emacs cannot find a font to display a character. But more on that later.&lt;/p&gt;&lt;p&gt;To create a fontset, you can use &lt;code&gt;create-fontset-from-fontset-spec&lt;/code&gt; and pass it a bunch of X Logical Font Descriptions, each for a font you want to include. I find that tedious. Instead, I like to create a fontset with a single ASCII font and use &lt;code&gt;set-fontset-font&lt;/code&gt; to add other fonts later, like this:&lt;/p&gt;&lt;pre class="code-block"&gt;(create-fontset-from-fontset-spec
 (font-xlfd-name
  (font-spec :family "IBM Plex Mono"
             :size 13
             :registry "fontset-my fontset")))&lt;/pre&gt;&lt;p&gt;Make sure you put the short fontset name under the &lt;code&gt;:registry&lt;/code&gt; spec. The code above creates the fontset, and returns its long name,&lt;/p&gt;&lt;pre class="code-block"&gt;-*-ibm plex mono-*-*-*-*-13-*-*-*-*-*-fontset-my fontset&lt;/pre&gt;&lt;p&gt;Now we can add a Chinese font and a Greek font:&lt;/p&gt;&lt;pre class="code-block"&gt;(set-fontset-font
 "fontset-my fontset"
 'han (font-spec :family "Source Han Serif" :size 12))
(set-fontset-font
 "fontset-my fontset"
 'greek (font-spec :family "Academica"))&lt;/pre&gt;&lt;p&gt;If you are not familiar with &lt;code&gt;set-fontset-font&lt;/code&gt;, &lt;a href="https://archive.casouri.cc/note/2021/fontset/http:/idiocy.org/emacs-fonts-and-fontsets.html"&gt;&lt;em&gt;Emacs, fonts and fontsets&lt;/em&gt;&lt;/a&gt; is a good read.&lt;/p&gt;&lt;h2 id="Apply%20a%20fonset" class="section"&gt;Apply a fonset&lt;/h2&gt;&lt;p&gt;Although the manual says we can use a fontset wherever a font is appropriate, it is not entirely true. If you pass your fontset through the &lt;code&gt;:font&lt;/code&gt; attribute in &lt;code&gt;set-face-attribute&lt;/code&gt;, &lt;a id="footref:takes-ascii" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Atakes-ascii"&gt;Emacs takes the ASCII font from the fontset and only uses the ASCII font for the face&lt;sup class="inline-footref"&gt;1&lt;/sup&gt;&lt;/a&gt;. The real way to do it is to use the undocumented &lt;code&gt;:fontset&lt;/code&gt; attribute:&lt;/p&gt;&lt;pre class="code-block"&gt;(set-face-attribute
 'some-face nil :fontset "fontset-my fontset")&lt;/pre&gt;&lt;p&gt;That’s not all. While the above code works for most faces, setting &lt;code&gt;:fontset&lt;/code&gt; for &lt;code&gt;default&lt;/code&gt; will not work as you expected, because Emacs again &lt;a id="footref:default" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Adefault"&gt;only takes the ASCII font, even if you use the &lt;code&gt;fontset&lt;/code&gt; attribute&lt;sup class="inline-footref"&gt;2&lt;/sup&gt;&lt;/a&gt;. So don’t set the fontset for the &lt;code&gt;default&lt;/code&gt; face; instead, just modify &lt;code&gt;fontset-default&lt;/code&gt; (it’s the ultimate fall-back fontset we mentioned earlier) for Unicode fonts, and use whatever method you like for ASCII font. If you read &lt;a href="https://archive.casouri.cc/note/2021/fontset/http:/idiocy.org/emacs-fonts-and-fontsets.html"&gt;&lt;em&gt;Emacs, fonts and fontsets&lt;/em&gt;&lt;/a&gt;, you’ll know we can modify &lt;code&gt;fontset-default&lt;/code&gt; by either&lt;/p&gt;&lt;pre class="code-block"&gt;(set-fontset-font "fontset-default" ...)&lt;/pre&gt;&lt;p&gt;or&lt;/p&gt;&lt;pre class="code-block"&gt;(set-fontset-font t ...)&lt;/pre&gt;&lt;p&gt;Technically you could set the &lt;code&gt;font&lt;/code&gt; attribute of a frame to a fontset by &lt;code&gt;set-frame-font&lt;/code&gt; and it works fine. But as soon as you change any font-related attributes in &lt;code&gt;default&lt;/code&gt; face, like font size, your fontset in the frame attribute will be overwritten by the font derived from &lt;code&gt;default&lt;/code&gt; face. So the best way is still to just modify &lt;code&gt;fontset-default&lt;/code&gt;.&lt;/p&gt;&lt;div id="footdef:takes-ascii" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Atakes-ascii"&gt;1&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;According to &lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/github.com/emacs-mirror/emacs/blob/11e5c7d8ca58cc946930048b5c88c8f582d4d5d8/src/xfaces.c#L3391"&gt;the source&lt;/a&gt;.&lt;/div&gt;&lt;/div&gt;&lt;div id="footdef:default" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Adefault"&gt;2&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;Basically, if the face is &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;set-face-attribute&lt;/code&gt; calls &lt;code&gt;set_font_frame_param&lt;/code&gt; (&lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/github.com/emacs-mirror/emacs/blob/11e5c7d8ca58cc946930048b5c88c8f582d4d5d8/src/xfaces.c#L3514"&gt;source&lt;/a&gt;), which only looks at the &lt;code&gt;:font&lt;/code&gt; attribute (&lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/github.com/emacs-mirror/emacs/blob/11e5c7d8ca58cc946930048b5c88c8f582d4d5d8/src/xfaces.c#L3685"&gt;source&lt;/a&gt;).&lt;/div&gt;&lt;/div&gt;&lt;h2 id="Further%20reading" class="section"&gt;Further reading&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Command &lt;code&gt;list-fontsets&lt;/code&gt; lists all the defined fontsets.&lt;/li&gt;&lt;li&gt;Command &lt;code&gt;describe-fontset&lt;/code&gt; shows which font is each character assigned to in a fontset.&lt;/li&gt;&lt;li&gt;Manual page: &lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/www.gnu.org/software/emacs/manual/html_node/emacs/Fontsets.html"&gt;&lt;em&gt;Fontsets, Emacs User Manual&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Another manual page: &lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/www.gnu.org/software/emacs/manual/html_node/elisp/Fontsets.html"&gt;&lt;em&gt;Fontsets, Emacs Lisp Manual&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry>
  <entry><title>Code Page 437</title><link href="https://archive.casouri.cc/note/2021/code-page-437"/><id>urn:uuid:97279de0-28c5-11ec-b9e1-e3d1f57bb295</id><updated>2021-10-23T00:11:00.00-05:00</updated><content type="html">&lt;p&gt;So I was installing a new OS on my desktop machine, and for some technical reasons I need to install the OS manually. That means typing in a console. I couldn’t help but wonder: what the font is it showing?&lt;/p&gt;&lt;figure&gt;&lt;img alt="Screenshot of the console" src="https://archive.casouri.cc/note/2021/code-page-437/console.jpeg"/&gt;
&lt;figcaption&gt;I was typing in this&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Turns out the typeface isn’t even a typeface. It is a encoding that extends ASCII. It maps 8-bit patterns to characters. For example, &lt;code&gt;10000110&lt;/code&gt; corresponds to “å”. According to Wikipedia, It is the“standard character set of the original IBM PC”, and it “remains the primary set in the core of any EGA and VGA-compatible graphic cards”. Basically this is the most basic font on a personal computer, stored directly in hardware.&lt;/p&gt;&lt;p&gt;This character set is supposed to contain many characters including fancy ones like “⌠”, “☺”, “§”, etc. But my graphic card is missing most of the non-basic characters. (How disappointing!)&lt;/p&gt;&lt;figure&gt;&lt;img alt="A screenshot specimen" src="https://archive.casouri.cc/note/2021/code-page-437/specimen.jpeg"/&gt;
&lt;figcaption&gt;Many characters are missing&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;I don’t think this font is pretty or anything. What makes it so interesting to me is that it is such ubiquitous yet most people never notice it. Next time &lt;a id="footref:PC" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3APC"&gt;when your PC starts up or crashes&lt;sup class="inline-footref"&gt;1&lt;/sup&gt;&lt;/a&gt;, see if you can spot any message printed in this font.&lt;/p&gt;&lt;p&gt;You can even download the font file for this font: &lt;a href="https://archive.casouri.cc/note/2021/code-page-437/https:/cp437.github.io"&gt;&lt;em&gt;Code Page 437&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;PS. this makes me wonder if Mac has something similar, and sure enough, there is. &lt;a href="https://archive.casouri.cc/note/2021/code-page-437/https:/apple.stackexchange.com/questions/157038/what-font-is-used-during-verbose-boot-mode"&gt;Someone asked about it on StackExchange&lt;/a&gt;. I bet even less people know about this one. I for one have never seen it despite using a MacBook for years (That’s probably a good thing, as one only see it when something goes hopelessly wrong.)&lt;/p&gt;&lt;p&gt;PPS. On Linux, you can drop yourself into a console by typing Ctrl+Alt+F1/F2/etc. Usually that screen is printed in &lt;a href="https://archive.casouri.cc/note/2021/code-page-437/http:/terminus-font.sourceforge.net"&gt;Terminus&lt;/a&gt;.&lt;/p&gt;&lt;div id="footdef:PC" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3APC"&gt;1&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;You still use a PC, do you?&lt;/div&gt;&lt;/div&gt;</content></entry>
  <entry><title>Dutch 801 Headline</title><link href="https://archive.casouri.cc/note/2021/dutch-801"/><id>urn:uuid:78a32c96-227f-11ec-9fc2-63ecfe829692</id><updated>2021-09-30T23:18:00.00-05:00</updated><content type="html">&lt;p&gt;Today’s typeface isn’t really interesting in itself, but in the way I came across it. It’s a long story, are you ready? Ok, so I was reading assigned papers for my OS class, and I started on this one:&lt;/p&gt;&lt;p&gt;&lt;img alt="A clip of the paper" src="https://archive.casouri.cc/note/2021/dutch-801/hydra.jpeg"/&gt;&lt;/p&gt;&lt;p&gt;The title immediately caught my attention: it’s a elegant, graceful font. So I clipped an image and searched on myfont.com, and it turns out to be ... Dutch 801 Headline.&lt;/p&gt;&lt;p&gt;The end.&lt;/p&gt;&lt;p&gt;I don’t know about you, but isn’t it a rather strange name for a typeface? Why Dutch? Why 801? I still don’t know the answer. Anyway, I think its a cool name. Maybe the one who named it thought the same.&lt;/p&gt;&lt;p&gt;Despite its interesting name, information about this typeface is quite scarce. I only know it is Bitstream’s version of Times New Roman (ie, clone). I was kind of surprised when I found out, because I never associated Times New Roman with elegance. Maybe enlarging a font naturally releases it from its humble form, and brings out its gracefulness.&lt;/p&gt;&lt;figure&gt;&lt;img alt="A larger clip of the title" src="https://archive.casouri.cc/note/2021/dutch-801/hydra-large.jpeg"/&gt;
&lt;figcaption&gt;The title in its full glory&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="Clip for another title" src="https://archive.casouri.cc/note/2021/dutch-801/tenex.jpeg"/&gt;
&lt;figcaption&gt;Another article title&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;As for the body text, I can only assume it to be Dutch 801 Text. I didn’t bother to check though.&lt;/p&gt;&lt;p&gt;&lt;img alt="A clip of the body text" src="https://archive.casouri.cc/note/2021/dutch-801/body.jpeg"/&gt;&lt;/p&gt;</content></entry>
  <entry><title>Academica</title><link href="https://archive.casouri.cc/note/2021/academica"/><id>urn:uuid:8a5678de-2181-11ec-9b77-8b26fea6a693</id><updated>2021-09-29T17:01:00.00-05:00</updated><content type="html">&lt;p&gt;&lt;a href="https://archive.casouri.cc/note/2021/academica/https:/www.stormtype.com/families/academica"&gt;Academica&lt;/a&gt; is a typeface I found out when reading &lt;a href="https://archive.casouri.cc/note/2021/academica/https:/aeon.co"&gt;&lt;em&gt;aeon&lt;/em&gt;&lt;/a&gt; (a digital magazine in Science and Humanities). Academica is designed by Josef Týfa for scientific texts. The original design was cut and cast in metal in 1968, and in 2003, Týfa and František Štorm worked together to rework it for digital printing.&lt;/p&gt;&lt;p&gt;Academica shares some similarities with Charter in tall x‑height and emphasize on legibility, but the similarity pretty much ends there. Comparing to Charter, Academica is considerably blacker. And comparing to Charter’s &lt;a id="footref:stoic" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Astoic"&gt;stoic stint on curves&lt;sup class="inline-footref"&gt;1&lt;/sup&gt;&lt;/a&gt;, Academica is lavishly rounded, tapered, bent, squished and stretched. In fact, I don’t even know why am I comparing it to Charter, Academica reminds me more of another typeface (that I dig), &lt;a href="https://archive.casouri.cc/note/2021/academica/https:/en.wikipedia.org/wiki/Cooper_Black"&gt;Cooper Black&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;img alt="A specimen for some lower-case Latin letters" src="https://archive.casouri.cc/note/2021/academica/specimen1.png"/&gt;&lt;/p&gt;&lt;p&gt;The alien-looking 0 is perhaps the most salient character (pun intended) in Academica. Instead of simply narrowing 0 to distinguish it from capital O, Academica “flipped” it such that the horizontal stroke is thicker than the vertical. The 0 is really the culmination of the overall vibe of Academica—little roundish goofiness here and there, slightly throwing the reader off; but when you zoom away, you see a legible, realistic academic typeface.&lt;/p&gt;&lt;p&gt;&lt;img alt="A specimen for text “2001”" src="https://archive.casouri.cc/note/2021/academica/specimen2.png"/&gt;&lt;/p&gt;&lt;p&gt;I love the color of Academica, it’s thiccc ;-) Use it for body text, and the dense, full color is beautiful. Looking at a block of Academica, you can almost feel the energy of live imbued in every corner. Also, the tall x-height means you can pack more lines into a page, increasing the information density.&lt;/p&gt;&lt;p&gt;Overall, Academica feels humane to me. It is a practical typeface for serious scientific publications, but in the same time has its very own quirky character. I’m very fond of it. It isn’t that expensive either. If you buy it on &lt;a href="https://archive.casouri.cc/note/2021/academica/https:/www.myfonts.com"&gt;myfonts.com&lt;/a&gt;, each font costs $44 (at the time of writing). &lt;a id="footref:need" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Aneed"&gt;So regular, italic and bold&lt;sup class="inline-footref"&gt;2&lt;/sup&gt;&lt;/a&gt; combined costs $132. That’s more than a cup of coffee, but still less than 20 cups (I think?)&lt;/p&gt;&lt;p&gt;Some more specimen:&lt;/p&gt;&lt;figure&gt;&lt;img alt="A specimen for body text" src="https://archive.casouri.cc/note/2021/academica/specimen3.png"/&gt;
&lt;figcaption&gt;Academica Text (Regular) in body text&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img alt="A specimen for Light/Book weight" src="https://archive.casouri.cc/note/2021/academica/specimen4.png"/&gt;
&lt;figcaption&gt;Academica Book (Light) in slightly larger size&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;Further reading:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://archive.casouri.cc/note/2021/academica/https:/fontsinuse.com/typefaces/13032/academica"&gt;&lt;em&gt;Fonts in Use: Academica&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;The &lt;a href="https://archive.casouri.cc/note/2021/academica/StormType-AcademicaSpecimenA4.pdf"&gt;Official specimen&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div id="footdef:stoic" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Astoic"&gt;1&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;Of course, there is nothing bad about stoic outlines. Matthew Carter designed Charter for low-resolution laser printers (which will muddle any delicate detail on the character), and aimed for economic use of curves to accommodate low-memory computers and printers. More over, the crisp, direct, clean outline is actually one of Charter’s virtues. (Edit: Actually, economic use of curves turns out to be a premature optimization, but Carter liked the style anyway and kept the design.)&lt;/div&gt;&lt;/div&gt;&lt;div id="footdef:need" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Aneed"&gt;2&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;Regular, italic and bold are really all you need, sometimes you don’t even need bold. If you want to use Academica in a larger size (larger than 13pt), then Light, Light italic and Regular is also a good combination.&lt;/div&gt;&lt;/div&gt;</content></entry>
  <entry><title>RFC: Emacs tree-sitter integration</title><link href="https://archive.casouri.cc/note/2021/emacs-tree-sitter"/><id>urn:uuid:484e573e-207f-11ec-bd91-975a51a5f3f1</id><updated>2021-09-28T10:12:00.00-05:00</updated><content type="html">&lt;p&gt;&lt;a href="https://archive.casouri.cc/note/2021/emacs-tree-sitter/https:/tree-sitter.github.io/tree-sitter"&gt;Tree-sitter&lt;/a&gt; is a incremental parser that can provide a concrete syntax tree for the source code and is fast enough to parse on each key press. It has supported a wide range of languages, and support for more languages is on the way.&lt;/p&gt;&lt;p&gt;I’ve been working on a integration of tree-sitter library into Emacs’ core. The integration consists of two parts, first the direct translate of tree-sitter’s API, second the integration with Emacs’ font-lock and indent system.  The first part is completed and is rather uncontentious. I’d appreciate comments on the second: Is the interface easy to understand? Is it easy to use? Is it flexible enough for every language?&lt;/p&gt;&lt;p&gt;Whether you are a major mode author or just a interested Emacs user, I invite you to try hacking with this tree-sitter integration—recreate existing major mode features (font-lock, indent), create new features (structured editing, etc)—and tell me how well it works. Better yet, provide some suggestions on improving the interface.&lt;/p&gt;&lt;h2 id="Building%20Emacs%20with%20tree-sitter%20support" class="section"&gt;Building Emacs with tree-sitter support&lt;/h2&gt;&lt;h3 id="Install%20tree-sittter" class="subsection"&gt;Install tree-sittter&lt;/h3&gt;&lt;p&gt;First, install libtree-sitter, either by a package manager, or from source:&lt;/p&gt;&lt;pre class="code-block"&gt;git clone https://github.com/tree-sitter/tree-sitter.git
cd tree-sitter
make
make install&lt;/pre&gt;&lt;p&gt;This should install libtree-sitter in standard location.&lt;/p&gt;&lt;h3 id="Build%20Emacs" class="subsection"&gt;Build Emacs&lt;/h3&gt;&lt;p&gt;Then, build Emacs from my GitHub repository. Make sure you clone the &lt;code&gt;ts&lt;/code&gt; branch.&lt;/p&gt;&lt;pre class="code-block"&gt;git clone https://github.com/casouri/emacs.git --branch ts
./autogen.sh
./configure
make&lt;/pre&gt;&lt;p&gt;No need for special configure flags, tree-sitter is enabled automatically if libtree-sitter is present on the system. Now Emacs can be started by&lt;/p&gt;&lt;pre class="code-block"&gt;src/emacs&lt;/pre&gt;&lt;h3 id="Get%20language%20definitions" class="subsection"&gt;Get language definitions&lt;/h3&gt;&lt;p&gt;To use tree-sitter features in any meaningful way, we also need the language definition, eg, libtree-sitter-c for C. I wrote a script for automatically retrieving and compiling some of the libraries. The following commands&lt;/p&gt;&lt;pre class="code-block"&gt;git clone https://github.com/casouri/tree-sitter-module.git
cd tree-sitter-module
./batch-new.sh&lt;/pre&gt;&lt;p&gt;should produce libraries for C, JSON, Go, HTML, JavaScript, CSS and Python and store them in &lt;code&gt;dist&lt;/code&gt; directory. From there you can copy these libraries to a standard path, or add that directory to &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;You can also find pre-built libraries in the release page: &lt;a href="https://archive.casouri.cc/note/2021/emacs-tree-sitter/https:/github.com/casouri/tree-sitter-module/releases/tag/v2,0"&gt;&lt;em&gt;tree-sitter-module release v2.0&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;&lt;h2 id="Basic%20tree-sitter%20features" class="section"&gt;Basic tree-sitter features&lt;/h2&gt;&lt;p&gt;I suggest reading the tree-sitter node in the manual first, it covers how to create a parser, how to retrieve a node, how to pattern match nodes, and more. You can access the manual by typing&lt;/p&gt;&lt;pre class="code-block"&gt;C-h i m elisp RET g Parsing Program Source RET&lt;/pre&gt;&lt;p&gt;The command(s) above opens the Info reader, goes to &lt;em&gt;Elisp Reference Manual&lt;/em&gt;, and opens the “Parsing Program Source” node, which contains manual for tree-sitter. Alternatively, you can read &lt;a href="https://archive.casouri.cc/note/2021/emacs-tree-sitter/Parsing-Program-Source.html"&gt;the tree-sitter node&lt;/a&gt; that I clipped from the HTML manuel.&lt;/p&gt;&lt;p&gt;Once you’ve read the manual, you can &lt;code&gt;(require 'tree-sitter)&lt;/code&gt; and hack away!&lt;/p&gt;&lt;p&gt;The manual only documents basic features of tree-sitter, leaving out font-lock and indent integration, because I expect the latter to change. They are instead documented below.&lt;/p&gt;&lt;h2 id="Font-lock%20interface" class="section"&gt;Font-lock interface&lt;/h2&gt;&lt;p&gt;(From now on, I assume you have read the manual and I will use concepts introduced in the manual without explanation.)&lt;/p&gt;&lt;p&gt;If you are familiar with font-lock in Emacs, you know it is primarily configured by &lt;code&gt;font-lock-defaults&lt;/code&gt;: major mode sets this variable with language-specific configuration, font-lock takes that variable and populate &lt;code&gt;font-lock-keywords&lt;/code&gt;, which directly defines the pattern to fontify.&lt;/p&gt;&lt;h3 id="tree-sitter-font-lock-settings" class="subsection"&gt;&lt;code&gt;tree-sitter-font-lock-settings&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;a id="footref:ts-name" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Ats-name"&gt;Tree-sitter&lt;sup class="inline-footref"&gt;1&lt;/sup&gt;&lt;/a&gt; provides two analogues variables, &lt;code&gt;tree-sitter-font-lock-defaults&lt;/code&gt; and &lt;code&gt;tree-sitter-font-lock-settings&lt;/code&gt;. &lt;code&gt;tree-sitter-font-lock-settings&lt;/code&gt; is a list of &lt;code&gt;SETTING&lt;/code&gt;s where each &lt;code&gt;SETTING&lt;/code&gt; looks like&lt;/p&gt;&lt;pre class="code-block"&gt;(LANGUAGE QUERY)&lt;/pre&gt;&lt;p&gt;&lt;code&gt;LANGUAGE&lt;/code&gt; is the language this setting should use, and &lt;code&gt;QUERY&lt;/code&gt; is either a string or a sexp query. Each capture name in &lt;code&gt;QUERY&lt;/code&gt; is either a face name, in which case the captured node is fontified in that face, or a function name, in which case the captured node is passed to the function for fontification. Specifically, the function is passed three arguments &lt;code&gt;(BEG END NODE)&lt;/code&gt;, where &lt;code&gt;BEG&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; is the beginning and end position of the node in the buffer, for convenience.&lt;/p&gt;&lt;p&gt;An example &lt;code&gt;SETTING&lt;/code&gt; for C is&lt;/p&gt;&lt;pre class="code-block"&gt;(tree-sitter-c ; LANGUAGE
 ((null) @font-lock-constant-face
  (true) @font-lock-constant-face
  (false) @font-lock-constant-face)) ; QUERY&lt;/pre&gt;&lt;div id="footdef:ts-name" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Ats-name"&gt;1&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;From now on, “tree-sitter” refers to the Emacs integration of tree-sitter.&lt;/div&gt;&lt;/div&gt;&lt;h3 id="tree-sitter-font-lock-defaults" class="subsection"&gt;&lt;code&gt;tree-sitter-font-lock-defaults&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Tree-sitter font-lock, like font-lock, support fontification at different levels of decoration (controlled by &lt;code&gt;font-lock-maximum-decoration&lt;/code&gt;). And this is the primary purpose of &lt;code&gt;tree-sitter-font-lock-defaults&lt;/code&gt;. Its value is a list of&lt;/p&gt;&lt;pre class="code-block"&gt;(DEFAULT :KEYWORD VALUE...)&lt;/pre&gt;&lt;p&gt;Where each &lt;code&gt;DEFAULT&lt;/code&gt; may be a symbol or a list of symbols. The symbol should be either a variable containing &lt;code&gt;(LANGUAGE QUERY)&lt;/code&gt;, or a function that returns that.  If &lt;code&gt;DEFAULT&lt;/code&gt; is a list, each symbol corresponds to a decoration level. For example, if I want to implement three levels of decoration for C, I would populate &lt;code&gt;tree-sitter-font-lock-defaults&lt;/code&gt; with&lt;/p&gt;&lt;pre class="code-block"&gt;(((c-font-lock-settings-1
   c-font-lock-settings-2
   c-font-lock-settings-3)
  :KEYWORD VALUE...))&lt;/pre&gt;&lt;p&gt;where &lt;code&gt;c-font-lock-settings-1&lt;/code&gt; would contain, say,&lt;/p&gt;&lt;pre class="code-block"&gt;(tree-sitter-c
 ((null) @font-lock-constant-face
  (true) @font-lock-constant-face
  (false) @font-lock-constant-face))&lt;/pre&gt;&lt;p&gt;for those who need no more. And the other two levels could be for the rest mortals. As for &lt;code&gt;:KEYWORD&lt;/code&gt; and &lt;code&gt;VALUE&lt;/code&gt;, they are analogues to that in &lt;code&gt;font-lock-defaults&lt;/code&gt;, used for specifying other configurations. Currently they are not used for tree-sitter font-lock.&lt;/p&gt;&lt;p&gt;To enable tree-sitter font-lock, a major mode should first assign &lt;code&gt;tree-sitter-font-lock-defaults&lt;/code&gt;, then call &lt;code&gt;tree-sitter-font-lock-enable&lt;/code&gt;. For example,&lt;/p&gt;&lt;pre class="code-block"&gt;(define-derived-mode ts-c-mode prog-mode "tree-sitter C"
  (setq-local tree-sitter-font-lock-defaults
              '((ts-c-tree-sitter-settings-1)))
  (tree-sitter-enable-font-lock))&lt;/pre&gt;&lt;h2 id="Indentation" class="section"&gt;Indentation&lt;/h2&gt;&lt;p&gt;In Emacs, indentation is provided by &lt;code&gt;indent-line-function&lt;/code&gt;. Tree-sitter provides a convenient system, &lt;em&gt;tree-sitter-simple-indent&lt;/em&gt;, to simplify the implementation of a indenting function. To use it, bind &lt;code&gt;indent-line-function&lt;/code&gt; to &lt;code&gt;tree-sitter-indent&lt;/code&gt;, and fill in indentation configurations in &lt;code&gt;tree-sitter-simple-indent-rules&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;code&gt;tree-sitter-simple-indent-rules&lt;/code&gt; is a list of rules, and each rule looks like&lt;/p&gt;&lt;pre class="code-block"&gt;(MATCHER ANCHOR OFFSET)&lt;/pre&gt;&lt;p&gt;When indenting, &lt;em&gt;tree-sitter-simple-indent&lt;/em&gt; finds the largest node that starts at the beginning of the current line, and matches it against each &lt;code&gt;MATCHER&lt;/code&gt; in &lt;code&gt;tree-sitter-simple-indent-rules&lt;/code&gt;. If &lt;code&gt;MATCHER&lt;/code&gt; matches that node, &lt;code&gt;ANCHOR&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; determines how to indent—find the column of &lt;code&gt;ANCHOR&lt;/code&gt; (which represents a point), and add &lt;code&gt;OFFSET&lt;/code&gt; to it.&lt;/p&gt;&lt;p&gt;By now you must be wondering what the heck is &lt;code&gt;MATCHER&lt;/code&gt;. It is a function that takes &lt;code&gt;(NODE PARENT BOL &amp;amp;rest _)&lt;/code&gt; as arguments, if the rule should apply to &lt;code&gt;NODE&lt;/code&gt;, it returns non-nil. &lt;code&gt;PARENT&lt;/code&gt; and &lt;code&gt;BOL&lt;/code&gt; (position of beginning of line) are provided just for convenience. The “&lt;code&gt;&amp;amp;rest _&lt;/code&gt;” part is required to allow the possibility to extend the interface in the future.&lt;/p&gt;&lt;p&gt;This function can do anything: check the type of that node, check the type of its parent, check whether this node is the first child node of its parent, etc. &lt;code&gt;ANCHOR&lt;/code&gt; is also a function that takes theses arguments, but it returns a point, the “anchor”. If the rule determines that the node should be indented two columns inward comparing to its parent, &lt;code&gt;ANCHOR&lt;/code&gt; should return the start of the parent node, and &lt;code&gt;OFFSET&lt;/code&gt; should be 2.&lt;/p&gt;&lt;p&gt;For example, the following rule matches any line that starts with the &lt;code&gt;null&lt;/code&gt; keyword, and indents the line inwards by two columns against the &lt;code&gt;null&lt;/code&gt;’s parent node.&lt;/p&gt;&lt;pre class="code-block"&gt;((lambda (n p bol &amp;amp;rest _)
   (equal (tree-sitter-node-type n) "null")) ; MATCHER
 (lambda (n p bol &amp;amp;rest _)
   (tree-sitter-node-start
    (tree-sitter-node-parent n))) ; ANCHOR
 2) ; OFFSET&lt;/pre&gt;&lt;p&gt;Of course, it is terribly tedious to write out every &lt;code&gt;MATCHER&lt;/code&gt; and &lt;code&gt;ANCHOR&lt;/code&gt; explicitly. &lt;em&gt;tree-sitter-simple-indent&lt;/em&gt; provides some predefined &lt;code&gt;MATCHER&lt;/code&gt; and &lt;code&gt;ANCHOR&lt;/code&gt; functions. Most of them are higher-order functions: they takes an argument and returns a function.&lt;/p&gt;&lt;p&gt;&lt;code&gt;MATCHER&lt;/code&gt; presets:&lt;/p&gt;&lt;dl&gt;&lt;dt&gt;&lt;code&gt;(parent-is TYPE)&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;Check that the parent has type &lt;code&gt;TYPE&lt;/code&gt;.&lt;/dd&gt;&lt;dt&gt;&lt;code&gt;(node-is TYPE)&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;Check that node has type &lt;code&gt;TYPE&lt;/code&gt;.&lt;/dd&gt;&lt;dt&gt;&lt;code&gt;(match NODE-TYPE PARENT-TYPE NODE-FIELD NODE-INDEX-MIN NODE-INDEX-MAX)&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;&lt;code&gt;NODE-TYPE&lt;/code&gt; checks for node’s type, &lt;code&gt;PARENT-TYPE&lt;/code&gt; checks for parent’s type, &lt;code&gt;NODE-FIELD&lt;/code&gt; checks for the field name for node int the parent, &lt;code&gt;NODE-INDEX-MIN&lt;/code&gt; and &lt;code&gt;NODE-INDEX-MAX&lt;/code&gt; limits the node’s index in the parent. Any argument left as nil are not checked. For example, to match the node that is the first child and has a parent of type &lt;code&gt;argument_list&lt;/code&gt;, use&lt;br/&gt;&lt;code&gt;(match nil "argument_list" nil nil 0 0)&lt;/code&gt;&lt;/dd&gt;&lt;dt&gt;&lt;code&gt;(query QUERY)&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;Queries the parent with &lt;code&gt;QUERY&lt;/code&gt;. Matches if the node is captured by any capture name.&lt;/dd&gt;&lt;dt&gt;&lt;code&gt;no-node&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;Matches null node. When the current line is empty, there is no node at the beginning, so the node is nil.&lt;/dd&gt;&lt;/dl&gt;&lt;p&gt;&lt;code&gt;ANCHOR&lt;/code&gt; presets:&lt;/p&gt;&lt;dl&gt;&lt;dt&gt;&lt;code&gt;first-child&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;Finds the first sibling of node, ie, the first child of the parent.&lt;/dd&gt;&lt;dt&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;Finds the parent node.&lt;/dd&gt;&lt;dt&gt;&lt;code&gt;prev-sibling&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;Finds node’s first sibling.&lt;/dd&gt;&lt;dt&gt;&lt;code&gt;no-indent&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;Do nothing, don’t indent. This is useful for a indenting a line inside a multiline string, where masterful inactivity is most preferred.&lt;/dd&gt;&lt;dt&gt;&lt;code&gt;prev-line&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;Find the named node on the previous line. This can be used when indenting an empty line: just indent like the previous node.&lt;/dd&gt;&lt;/dl&gt;&lt;h2 id="Some%20handy%20tools" class="section"&gt;Some handy tools&lt;/h2&gt;&lt;p&gt;I have two handy tools for you to work with tree-sitter more easily: first, &lt;code&gt;tree-sitter-inspect-mode&lt;/code&gt; will show the relevant information of the node at point in the mode-line; second, &lt;code&gt;tree-sitter-check-indent&lt;/code&gt; can check the indent result against a stock major mode. Check out their docstring for more detail.&lt;/p&gt;&lt;h2 id="Feedback" class="section"&gt;Feedback&lt;/h2&gt;&lt;p&gt;You can send a message to &lt;a href="https://archive.casouri.cc/note/2021/emacs-tree-sitter/https:/lists.gnu.org/mailman/listinfo/emacs-devel"&gt;&lt;em&gt;emacs-devel&lt;/em&gt;&lt;/a&gt;, or open an issue on the &lt;a href="https://archive.casouri.cc/note/2021/emacs-tree-sitter/https:/github.com/casouri/emacs"&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt;&lt;h2 id="An%20example" class="section"&gt;An example&lt;/h2&gt;&lt;p&gt;All these must be pretty confusing without seeing a concrete example, so here it is. This example code is for a demo C major mode, &lt;code&gt;ts-c-mode&lt;/code&gt;, defined in the “&lt;code&gt;;;; Lab&lt;/code&gt;” section in &lt;code&gt;tree-sitter.el&lt;/code&gt;. (Here is a &lt;a href="https://archive.casouri.cc/note/2021/emacs-tree-sitter/https:/github.com/casouri/emacs/blob/350ae9cc19e478f08468443843f63bdf005d9d92/lisp/tree-sitter.el#L640"&gt;link to the file on GitHub&lt;/a&gt;.)&lt;/p&gt;&lt;p&gt;Indent:&lt;/p&gt;&lt;pre class="code-block"&gt;(defvar ts-c-tree-sitter-indent-rules
  `((tree-sitter-c
     ;; Empty line.
     (no-node prev-line 0)

     ;; Function/struct definition body {}.
     ((match nil "function_definition" "body") parent 0)
     ((node-is "field_declaration_list") parent 0)

     ;; Call expression.
     ((parent-is "call_expression") parent 2)

     ;; If-else.
     ((match nil "if_statement" "condition") parent 2)
     ((match nil "if_statement" "consequence") parent 2)
     ((match nil "if_statement" "alternative") parent 2)
     ((match nil "switch_statement" "condition")  parent 2)
     ((node-is "else") parent 0)

     ;; Switch case.
     ((parent-is "case_statement") parent 2)
     ((node-is "case_statement") parent 0)

     ;; { and }.
     ((node-is "compound_statement") parent 2)
     ((node-is "}") parent 0)

     ;; Multi-line string.
     ((parent-is "string_literal") no-indent 0)

     ;; List.
     ,@(cl-loop for type in '("compound_statement" "initializer_list"
                              "argument_list" "parameter_list"
                              "field_declaration_list")
                collect `((match nil ,type nil 0 0) parent 2)
                collect `((match nil ,type nil 1) first-sibling 0)))))&lt;/pre&gt;&lt;p&gt;Font-lock:&lt;/p&gt;&lt;pre class="code-block"&gt;(defvar ts-c-tree-sitter-settings-1
  '(tree-sitter-c
    ((null) @font-lock-constant-face
     (true) @font-lock-constant-face
     (false) @font-lock-constant-face

     (comment) @font-lock-comment-face

     (system_lib_string) @ts-c-fontify-system-lib

     (unary_expression
      operator: _ @font-lock-negation-char-face)

     (string_literal) @font-lock-string-face
     (char_literal) @font-lock-string-face



     (function_definition
      declarator: (identifier) @font-lock-function-name-face)

     (declaration
      declarator: (identifier) @font-lock-function-name-face)

     (function_declarator
      declarator: (identifier) @font-lock-function-name-face)



     (init_declarator
      declarator: (identifier) @font-lock-variable-name-face)

     (parameter_declaration
      declarator: (identifier) @font-lock-variable-name-face)

     (preproc_def
      name: (identifier) @font-lock-variable-name-face)

     (enumerator
      name: (identifier) @font-lock-variable-name-face)

     (field_identifier) @font-lock-variable-name-face

     (parameter_list
      (parameter_declaration
       (identifier) @font-lock-variable-name-face))

     (pointer_declarator
      declarator: (identifier) @font-lock-variable-name-face)

     (array_declarator
      declarator: (identifier) @font-lock-variable-name-face)

     (preproc_function_def
      name: (identifier) @font-lock-variable-name-face
      parameters: (preproc_params
                   (identifier) @font-lock-variable-name-face))



     (type_identifier) @font-lock-type-face
     (primitive_type) @font-lock-type-face

     "auto" @font-lock-keyword-face
     "break" @font-lock-keyword-face
     "case" @font-lock-keyword-face
     "const" @font-lock-keyword-face
     "continue" @font-lock-keyword-face
     "default" @font-lock-keyword-face
     "do" @font-lock-keyword-face
     "else" @font-lock-keyword-face
     "enum" @font-lock-keyword-face
     "extern" @font-lock-keyword-face
     "for" @font-lock-keyword-face
     "goto" @font-lock-keyword-face
     "if" @font-lock-keyword-face
     "register" @font-lock-keyword-face
     "return" @font-lock-keyword-face
     "sizeof" @font-lock-keyword-face
     "static" @font-lock-keyword-face
     "struct" @font-lock-keyword-face
     "switch" @font-lock-keyword-face
     "typedef" @font-lock-keyword-face
     "union" @font-lock-keyword-face
     "volatile" @font-lock-keyword-face
     "while" @font-lock-keyword-face

     "long" @font-lock-type-face
     "short" @font-lock-type-face
     "signed" @font-lock-type-face
     "unsigned" @font-lock-type-face

     "#include" @font-lock-preprocessor-face
     "#define" @font-lock-preprocessor-face
     "#ifdef" @font-lock-preprocessor-face
     "#ifndef" @font-lock-preprocessor-face
     "#endif" @font-lock-preprocessor-face
     "#else" @font-lock-preprocessor-face
     "#elif" @font-lock-preprocessor-face
     )))&lt;/pre&gt;</content></entry>
  <entry><title>Don’t Use Rubber Pin Backings on Backpacks</title><link href="https://archive.casouri.cc/note/2021/secure-pin-backing"/><id>urn:uuid:093e8b2e-1515-11ec-b47c-a70e3cf20eb9</id><updated>2021-09-13T22:01:00.00-05:00</updated><content type="html">&lt;p&gt;If you like enamel pins, you know there are three types of backings: rubber, butterfly, and “secure/locking backing”. I grew up with butterfly backings, but nowadays, when you buy a enamel pin, more often than not, it comes with rubber backings.&lt;/p&gt;&lt;p&gt;Rubber backings—they feels insecure at first sight, but then the difficulty to remove one from the packaging might give you a false sense of security. Let me tell you: don’t trust them. My mistrust lost me a pin on my backpack. Thankfully I only lost one—the others are at most loose or missing one of two backings. Still, that’s enough proof that rubber backings are not suitable for surfaces that see a lot of movement, for example, a backpack.&lt;/p&gt;&lt;p&gt;Butterfly backings have their own problems: under stress or repeated use, they might loose the little metal butterfly wings. On top of that, they aren’t that much more secure than rubber backings. They won’t gradually loosen by time like the rubber backings do, but they can come loose or break under force.&lt;/p&gt;&lt;p&gt;That left the “secure/locking” backings. They can be a bit of pain when putting on and taking off—you need to get a feel for them. But they are secure. Buy a box of them from Amazon for a couple bucks, and your precious pins won’t gone missing from your backpack again.&lt;/p&gt;</content></entry>
  <entry><title>自动处理网页里的全角引号和标点挤压</title><link href="https://archive.casouri.cc/note/2021/full-width-quote"/><id>urn:uuid:05c234e6-d6b3-11eb-b625-f744d8291272</id><updated>2021-09-03T13:15:00.00-05:00</updated><content type="html">&lt;h2 id="%E5%85%A8%E8%A7%92%E5%BC%95%E5%8F%B7" class="section"&gt;全角引号&lt;/h2&gt;&lt;p&gt;在 Unicode 里&lt;span class="full-width-mark"&gt;，&lt;/span&gt;问号&lt;span class="full-width-mark"&gt;、&lt;/span&gt;叹号&lt;span class="full-width-mark"&gt;、&lt;/span&gt;各种括号都有全角半角两种版本&lt;span class="full-width-mark"&gt;，&lt;/span&gt;各自有独立的编码&lt;span class="full-width-mark"&gt;；&lt;/span&gt;但因为莫名的原因&lt;span class="full-width-mark"&gt;，&lt;/span&gt;最常用的引号却不在此列&lt;span class="full-width-mark"&gt;。&lt;/span&gt;中英混排的时候想要正确显示直角和半角的引号就很头疼&lt;span class="full-width-mark"&gt;；&lt;/span&gt;搞不好的话&lt;span class="full-width-mark"&gt;，&lt;/span&gt;中文里显示半角引号还不算太违和&lt;span class="full-width-mark"&gt;，&lt;/span&gt;英文里蹦出来一个全角引号就太丑了&lt;span class="full-width-mark"&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;CSS 没法自动区别什么时候用全角引号&lt;span class="full-width-mark"&gt;、&lt;/span&gt;什么时候用半角&lt;span class="full-width-mark"&gt;，&lt;/span&gt;只能靠标记&lt;span class="full-width-mark"&gt;。&lt;/span&gt;好在还没复杂到需要手工标记的地步&lt;span class="full-width-mark"&gt;，&lt;/span&gt;只要用程序检查引号前后的字是中文还是英文&lt;span class="full-width-mark"&gt;，&lt;/span&gt;以此标记全角还是半角&lt;span class="full-width-mark"&gt;，&lt;/span&gt;就基本不会出错&lt;span class="full-width-mark"&gt;。&lt;/span&gt;我现在的办法是这样&lt;span class="full-width-mark"&gt;，&lt;/span&gt;默认字体还是英文先中文后&lt;span class="full-width-mark"&gt;：&lt;/span&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;body {
  font-family: Charter, Source Han Serif CN, serif;
}&lt;/pre&gt;&lt;p&gt;需要全角的引号用 &lt;code&gt;span&lt;/code&gt; 标签包起来&lt;span class="full-width-mark"&gt;：&lt;/span&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;&amp;lt;span class="full-width-quote"&amp;gt;“&amp;lt;/span&amp;gt;&lt;/pre&gt;&lt;p&gt;然后用 CSS 指定中文字体&lt;span class="full-width-mark"&gt;：&lt;/span&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;span.full-width-quote {
  font-family: Srouce Han Serif CN, serif;
}&lt;/pre&gt;&lt;p&gt;怎么区别一个引号应该全角还是半角呢&lt;span class="full-width-mark"&gt;？&lt;/span&gt;我用了一个简单的判断方法&lt;span class="full-width-mark"&gt;：&lt;/span&gt;如果前或后紧挨着中文字符&lt;span class="full-width-mark"&gt;，&lt;/span&gt;就全角&lt;span class="full-width-mark"&gt;；&lt;/span&gt;如果前后都不是中文字符&lt;span class="full-width-mark"&gt;，&lt;/span&gt;就半角&lt;span class="full-width-mark"&gt;。&lt;/span&gt;我目前还没发现这个简单判断不够用的情况&lt;span class="full-width-mark"&gt;。&lt;/span&gt;这样一来还需要判断一个字符是不是中文&lt;span class="full-width-mark"&gt;，&lt;/span&gt;最简单的办法是检查字符的 Unicode codepoint 在不在中文区间内&lt;span class="full-width-mark"&gt;。&lt;/span&gt;常用汉字和标点符号在 &lt;code&gt;0x4E00&lt;/code&gt;–&lt;code&gt;0x9FFF&lt;/code&gt; 和 &lt;code&gt;0x3000&lt;/code&gt;–&lt;code&gt;0x303F&lt;/code&gt; 两个区间里&lt;span class="full-width-mark"&gt;，&lt;/span&gt;检查这两个就够了&lt;span class="full-width-mark"&gt;，&lt;/span&gt;其他的区间里都是生僻字&lt;span class="full-width-mark"&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2 id="%E6%A0%87%E7%82%B9%E6%8C%A4%E5%8E%8B" class="section"&gt;标点挤压&lt;/h2&gt;&lt;p&gt;全角引号搞好了&lt;span class="full-width-mark"&gt;，&lt;/span&gt;又会贪心标点挤压&lt;span class="full-width-mark"&gt;。&lt;/span&gt;没有标点挤压的时候&lt;span class="full-width-mark"&gt;，&lt;/span&gt;几个标点排在一起确实不大好看&lt;span class="full-width-mark"&gt;：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class="half300" alt="没有标点挤压的样子" src="https://archive.casouri.cc/note/2021/full-width-quote/%E4%BE%8B%E5%AD%901.png"/&gt;
&lt;figcaption&gt;&lt;a href="https://archive.casouri.cc/note/2021/full-width-quote/https:/archive.casouri.cat/rock/day/day-48/index.html"&gt;余日摇滚第48期&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;挤压以后就不那么空了&lt;span class="full-width-mark"&gt;：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class="half300" alt="有标点挤压的样子" src="https://archive.casouri.cc/note/2021/full-width-quote/%E4%BE%8B%E5%AD%902.png"/&gt;
&lt;figcaption&gt;&lt;a href="https://archive.casouri.cc/note/2021/full-width-quote/https:/archive.casouri.cat/rock/day/day-48/index.html"&gt;余日摇滚第48期&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;原理是设置 CSS 属性 &lt;code&gt;font-feature-settings: "halt"&lt;/code&gt;&lt;span class="full-width-mark"&gt;，&lt;/span&gt;启用 OpenType 的 &lt;code&gt;halt&lt;/code&gt; 特性&lt;span class="full-width-mark"&gt;。&lt;/span&gt;和全角引号一样&lt;span class="full-width-mark"&gt;，&lt;/span&gt;用程序自动识别需要挤压的标点&lt;span class="full-width-mark"&gt;，&lt;/span&gt;包在 &lt;code&gt;span&lt;/code&gt; 标签里&lt;span class="full-width-mark"&gt;。&lt;/span&gt;要注意的是&lt;span class="full-width-mark"&gt;，&lt;/span&gt;你用的字体要有 &lt;code&gt;halt&lt;/code&gt; 这个特性才行&lt;span class="full-width-mark"&gt;，&lt;/span&gt;我用的思源宋体是有的&lt;span class="full-width-mark"&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;具体怎么挤压标点符号&lt;span class="full-width-mark"&gt;，&lt;/span&gt;我没找到现成的标准或者算法&lt;span class="full-width-mark"&gt;，&lt;/span&gt;下面是我的方法&lt;span class="full-width-mark"&gt;。&lt;/span&gt;这个方法并不完整&lt;span class="full-width-mark"&gt;，&lt;/span&gt;只处理比较常见的情况&lt;span class="full-width-mark"&gt;，&lt;/span&gt;但对我来说够用了&lt;span class="full-width-mark"&gt;。&lt;/span&gt;如果读者知道更好的算法&lt;span class="full-width-mark"&gt;，&lt;/span&gt;请一定告诉我&lt;span class="full-width-mark"&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;首先&lt;span class="full-width-mark"&gt;，&lt;/span&gt;能挤压的标点符号可以分为三类&lt;span class="full-width-mark"&gt;：&lt;/span&gt;靠左&lt;span class="full-width-mark"&gt;，&lt;/span&gt;靠右&lt;span class="full-width-mark"&gt;，&lt;/span&gt;居中&lt;span class="full-width-mark"&gt;：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt="各种类型的标点符号" src="https://archive.casouri.cc/note/2021/full-width-quote/%E5%90%84%E7%B1%BB%E7%AC%A6%E5%8F%B7.png"/&gt;
&lt;figcaption&gt;&lt;a href="https://archive.casouri.cc/note/2021/full-width-quote/https:/www.w3.org/TR/2020/WD-clreq-20201101"&gt;&lt;span class="full-width-mark"&gt;《&lt;/span&gt;中文排版需求&lt;span class="squeeze full-width-mark"&gt;》&lt;/span&gt;&lt;span class="full-width-mark"&gt;，&lt;/span&gt;W3C Working Draft 01 November 2020&lt;span class="full-width-mark"&gt;，&lt;/span&gt;3.1.6 标点符号的宽度调整&lt;span class="full-width-mark"&gt;，&lt;/span&gt;有修改&lt;/a&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们不考虑居中的符号&lt;span class="full-width-mark"&gt;，&lt;/span&gt;因为简体中文普遍不用&lt;span class="full-width-mark"&gt;，&lt;/span&gt;而我以简体中文写作&lt;span class="full-width-mark"&gt;。&lt;/span&gt;程序从头到尾遍历每个字符&lt;span class="full-width-mark"&gt;，&lt;/span&gt;决定每个字符要不要挤压&lt;span class="full-width-mark"&gt;。&lt;/span&gt;挤不挤压取决于这个字符和其前后的字符&lt;span class="full-width-mark"&gt;，&lt;/span&gt;以伪码表达为&lt;span class="full-width-mark"&gt;：&lt;/span&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;遍历 字符：
  如果 此字符为靠左标点 且 后一字符为标点：
    挤压此字符
  如果 此字符为靠右标点 且 前一字符为靠右标点：
    挤压此字符&lt;/pre&gt;&lt;p&gt;这个算法运行的结果是这样&lt;span class="squeeze full-width-mark"&gt;：&lt;/span&gt;&lt;span class="full-width-mark"&gt;（&lt;/span&gt;&lt;span class="squeeze full-width-mark"&gt;（&lt;/span&gt;文字&lt;span class="squeeze full-width-mark"&gt;）&lt;/span&gt;&lt;span class="squeeze full-width-mark"&gt;）&lt;/span&gt;&lt;span class="squeeze full-width-mark"&gt;，&lt;/span&gt;&lt;span class="full-width-mark"&gt;（&lt;/span&gt;文&lt;span class="squeeze full-width-mark"&gt;）&lt;/span&gt;&lt;span class="full-width-mark"&gt;「&lt;/span&gt;字&lt;span class="squeeze full-width-mark"&gt;」&lt;/span&gt;&lt;span class="full-width-mark"&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a id="footref:subset" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Asubset"&gt;如果你用 &lt;code&gt;pyftsubset&lt;/code&gt; 压缩过字体文件&lt;sup class="inline-footref"&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;span class="full-width-mark"&gt;，&lt;/span&gt;注意它默认会把 &lt;code&gt;halt&lt;/code&gt; 这样的 OTF 特性扔掉&lt;span class="full-width-mark"&gt;，&lt;/span&gt;这样一来即使加上挤压标签也没有效果&lt;span class="full-width-mark"&gt;。&lt;/span&gt;压缩的时候加上 &lt;code&gt;--layout-features='*'&lt;/code&gt; 这个选项就可以保留所有 OTF 特性了&lt;span class="full-width-mark"&gt;。&lt;/span&gt;也可以用 &lt;code&gt;--layout-features='halt'&lt;/code&gt; 只保留 &lt;code&gt;halt&lt;/code&gt; 特性&lt;span class="full-width-mark"&gt;。&lt;/span&gt;&lt;/p&gt;&lt;div id="footdef:subset" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Asubset"&gt;1&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;参见 &lt;a href="https://archive.casouri.cc/note/2019/reduce-font-loading-time-in-my-blog/index.html"&gt;&lt;em&gt;Reduce Font Loading Time in My Blog&lt;/em&gt;&lt;/a&gt;&lt;span class="full-width-mark"&gt;。&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;h2 id="%E7%A0%B4%E6%8A%98%E5%8F%B7" class="section"&gt;破折号&lt;/h2&gt;&lt;p&gt;我还发现破折号有时会显示成 em dash&lt;span class="full-width-mark"&gt;（&lt;/span&gt;因为破折号在 Unicode 里其实就是 em dash&lt;span class="squeeze full-width-mark"&gt;）&lt;/span&gt;&lt;span class="full-width-mark"&gt;。&lt;/span&gt;解决方法和全角引号一样&lt;span class="full-width-mark"&gt;，&lt;/span&gt;包上全角的 &lt;code&gt;span&lt;/code&gt; 标签就可以了&lt;span class="full-width-mark"&gt;——&lt;/span&gt;这样就能正确显示破折号&lt;span class="full-width-mark"&gt;。&lt;/span&gt;&lt;/p&gt;</content></entry>
</feed>
