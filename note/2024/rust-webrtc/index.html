<!DOCTYPE html>
<html lang="en">
<head>
<title>Peer-to-peer Connection with WebRTC in Rust Using
webrtc-rs</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="./../../note-style.css">
<link rel="icon" type="image/png" href="./../../../favicon.png">
</head>
<body>
<header id="header" class="obviously-a-link">
<nav><a href="../../../index.html">Home</a><span>▶︎</span><a href=
"../../index.html">Notes</a><span>▶︎</span></nav>
</header>
<main id="body">
<article>
<div class="title">
<h1 class="main-title">Peer-to-peer Connection with WebRTC in Rust Using
webrtc-rs</h1>
</div>
<nav id="toc" class="obviously-a-link">
<h2>Table of Contents</h2>
<ol>
<li><a href="#Overall%20structure">Overall structure</a></li>
<li><a href="#WebRTC">WebRTC</a></li>
<li><a href="#Code">Code</a></li>
<li><a href="#DTLS">DTLS</a></li>
<li><a href="#SCTP">SCTP</a></li>
<li><a href="#Conclusion">Conclusion</a></li>
<li><a href="#Appendix%20A%2C%20a%20rcgen%20pitfall">Appendix A, a rcgen
pitfall</a></li>
</ol>
</nav>
<p>This is a guide for using <a href="https://webrtc.rs">webrtc-rs</a> to
create <span class="oldstyle-num">p2p</span> connections that can go
through <span class="smallcaps">nat</span> in Rust. This should be useful
for anyone that wants to create a <span class=
"oldstyle-num">p2p</span>/distributed program. I assume the reader knows
about <a id="footref:stun" class="footref-anchor obviously-a-link"
aria-label="Jump to footnote" href="#footdef%3Astun"><span class=
"smallcaps">stun</span>, <span class="smallcaps">ice</span><sup class=
"inline-footref">1</sup></a>, websocket. I’ll brefly explain how WebRTC
works. Reader also needs to know <span class="smallcaps">pem</span>,
<span class="smallcaps">der</span>, X.509, and <span class=
"smallcaps">pki</span> in general, for the security side of things.</p>
<p>I’m not an expert on WebRTC, just some dude that needs <span class=
"oldstyle-num">p2p</span> and spent some time figuring out how to use
webrt-rs for it; so if you spot some mistake, please do correct me!</p>
<div id="footdef:stun" class="footdef">
<div class="def-footref obviously-a-link"><a aria-label=
"Jump back to main text" href="#footref%3Astun">1</a></div>
<div class="def-footdef">Yuo can refer to this post: <a href=
"../2022/nat-what-do-they-do/index.html"><em>NAT traversal: STUN, TURN,
ICE, what do they actually do?</em></a></div>
</div>
<h2 id="Overall%20structure" class="section">Overall structure</h2>
<p>There are several parts in the system. First there is a bunch of
<span class="oldstyle-num">p2p</span> programs that want to connect to
each other, let’s call them peers. Then there needs to be a public-facing
server that every peer can connect to. You’ll need to write this server
and host it yourself. When peer A and B wants to connect to each other,
they both send a request to the public server (let’s call it S); S will
relay information between A and B, until A and B successfully establish a
<a id="footref:udp" class="footref-anchor obviously-a-link" aria-label=
"Jump to footnote" href="#footdef%3Audp"><span class=
"smallcaps">udp</span> “connection”<sup class=
"inline-footref">2</sup></a>. Finally, you need some <span class=
"smallcaps">stun</span> servers and maybe even <span class=
"smallcaps">turn</span> servers. There are plenty of free public
<span class="smallcaps">stun</span> servers (Google, Cloudflare, etc
hosts a bunch of them). On the other hand, free public <span class=
"smallcaps">turn</span> server is basically unheard of, since they’re so
easy to abuse.</p>
<div id="footdef:udp" class="footdef">
<div class="def-footref obviously-a-link"><a aria-label=
"Jump back to main text" href="#footref%3Audp">2</a></div>
<div class="def-footdef">Most of the time people use <span class=
"smallcaps">udp</span> for <span class="smallcaps">nat</span> traversal,
it’s rare to see <span class="smallcaps">tcp</span> connections: it’s
more difficult to establish through <span class="smallcaps">nat</span>,
and only used when the firewall blocks <span class=
"smallcaps">udp</span>.</div>
</div>
<h2 id="WebRTC" class="section">WebRTC</h2>
<p>The main purpose of WebRTC is for video conferencing and VoIP on
browsers; transfering arbitrary data requires much less hassle. So we
really don’t need most of the WebRTC that deals with video codec and
media channels. On top of that, WebRTC isn’t really a single protocol,
but rather a bunch of revived protocols plus a spec defining how to use
these protocols together. The Rust crate, webrtc-rs, implements each
underlining protocol (<span class="smallcaps">sctp</span>, <span class=
"smallcaps">dtls</span>, <span class="smallcaps">stun</span>,
<span class="smallcaps">ice</span>, ...) in separate crates, plus a
webrtc glue layer. So it’s possible to only use the underlining crates
and ignore the WebRTC layer altogether.</p>
<p>Technically, WebRTC already has what we want—<a href=
"https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Using_data_channels">data
channel</a>. It’s convenient if you’re using WebRTC in browsers with the
Javascript <span class="smallcaps">api</span>. Ironically, the data
channel spec added limits like message size on top of the underlying
protocol. webrtc-rs acknowledges this and provides a custom “detach”
feature to get a pure socket out of the datachannel. Either way, we need
to add some chunking/multiplexing layer on top so now we’re two layers on
top of <span class="smallcaps">sctp</span> with all the added chunking
and metadata overhead. So for us, it’s simpler and more flexible to use
the underlying protocol (<span class="smallcaps">sctp</span>) directly
instead of going through WebRTC.</p>
<p>The stack of WebRTC looks roughly like this:</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>WebRTC</td>
<td>Application</td>
</tr>
<tr>
<td><span class="smallcaps">sctp</span></td>
<td>Congestion and flow control</td>
</tr>
<tr>
<td><span class="smallcaps">dtls</span></td>
<td>Security</td>
</tr>
<tr>
<td><span class="smallcaps">ice</span></td>
<td><span class="smallcaps">nat</span> traversal</td>
</tr>
<tr>
<td><span class="smallcaps">udp</span></td>
<td>Transport</td>
</tr>
</tbody>
</table>
<p>Technically, <span class="smallcaps">dtls</span> (think of
<span class="smallcaps">tls</span> for <span class=
"smallcaps">udp</span>) should run on top of <span class=
"smallcaps">sctp</span> (think of <span class="smallcaps">tcp</span> Pro
Max), right? But WebRTC uses them the other way around. Probably because
<span class="smallcaps">sctp</span> provides a much nicer abstraction
than <span class="smallcaps">dtls</span>? Anyway, the designers explained
it in detail here: <a href=
"https://www.rfc-editor.org/rfc/rfc8831.html"><span class=
"oldstyle-num"><span class="smallcaps">rfc 8831</span></span></a>.</p>
<p>Now, here’s how WebRTC establish a connection between two peers A and
B:</p>
<ol>
<li>A creates a local <a id="footref:sdp" class=
"footref-anchor obviously-a-link" aria-label="Jump to footnote" href=
"#footdef%3Asdp"><span class="smallcaps">sdp</span><sup class=
"inline-footref">3</sup></a> (called offer), send it to B through a
<a id="footref:third-party" class="footref-anchor obviously-a-link"
aria-label="Jump to footnote" href="#footdef%3Athird-party">third-party
channel<sup class="inline-footref">4</sup></a>.</li>
<li>B receives A’s <span class="smallcaps">sdp</span>, sets it as the
remote <span class="smallcaps">sdp</span>, and sends B’s local
<span class="smallcaps">sdp</span> (called answer) to A. Meanwhile, B
starts gathering <span class="smallcaps">ice</span> candidate according
to the information in A’s <span class="smallcaps">sdp</span>.</li>
<li>A receives B’s <span class="smallcaps">sdp</span>, sets it to its
remote <span class="smallcaps">sdp</span>, and start gathering
<span class="smallcaps">ice</span> candidates according to B’s
<span class="smallcaps">sdp</span>.</li>
<li>While A and B gather <span class="smallcaps">ice</span> candidates,
they’ll send the candidates they gathered to each other through the
signaling server, <a id="footref:trickle" class=
"footref-anchor obviously-a-link" aria-label="Jump to footnote" href=
"#footdef%3Atrickle">and try to establish a (<span class=
"smallcaps">udp</span>) connection.<sup class=
"inline-footref">5</sup></a></li>
<li>Once the connection is established, A and B setup a <span class=
"smallcaps">dtls</span> connection over it, then a <span class=
"smallcaps">sctp</span> connection over the <span class=
"smallcaps">dtls</span> connection.</li>
</ol>
<div id="footdef:sdp" class="footdef">
<div class="def-footref obviously-a-link"><a aria-label=
"Jump back to main text" href="#footref%3Asdp">3</a></div>
<div class="def-footdef"><span class="smallcaps">sdp</span> (Session
Description Protocol) is basically a text packet with a bunch of metadata
used for establishing the connection, including media codec, <span class=
"smallcaps">ice</span> information, fingerprints, etc. See <a href=
"https://webrtchacks.com/sdp-anatomy/"><em>SDP Anatomy</em></a> for more.
There’s no need to know the details, because we’re going to use our own
kind of <span class="smallcaps">sdp</span>.</div>
</div>
<div id="footdef:third-party" class="footdef">
<div class="def-footref obviously-a-link"><a aria-label=
"Jump back to main text" href="#footref%3Athird-party">4</a></div>
<div class="def-footdef">WebRTC doesn’t specify this third-party, it can
be copy-pasting in Message app between two users, email, pidegon,
whatever. A common setup is to use a public “signaling server”, that’s
our server S.</div>
</div>
<div id="footdef:trickle" class="footdef">
<div class="def-footref obviously-a-link"><a aria-label=
"Jump back to main text" href="#footref%3Atrickle">5</a></div>
<div class="def-footdef">This is called “trickle <span class=
"smallcaps">ice</span>”. The alternative is to first gather all the
candidates, then try to establish <span class="smallcaps">ice</span>
connection. Trickle <span class="smallcaps">ice</span> is much faster and
is pretty much the standard practice now.</div>
</div>
<h3 id="Authentication" class="subsection">Authentication</h3>
<p>For authentication, A and B each generates a self-signed key, and hash
it to get a fingerprint, then put the fingerprint in their <span class=
"smallcaps">sdp</span>. Then they do the <span class=
"smallcaps">ice</span> exchange, and gets each other’s fingerprint from
the <span class="smallcaps">sdp</span>. When setting up the <span class=
"smallcaps">dtls</span> connection, they accpet any key that the other
end provides. But after the handshake completes, they verify that the
other end’s key matches the fingerprint</p>
<p>The implication here is that A and B must trust the signaling server
to deliver their <span class="smallcaps">sdp</span> securely.</p>
<p>The format of the fingerprint is specified in <a href=
"https://datatracker.ietf.org/doc/html/rfc8122"><span class=
"oldstyle-num"><span class="smallcaps">rfc 8122</span></span> section
<span class="oldstyle-num">5</span></a>: “A certificate fingerprint is a
secure one-way hash of the Distinguished Encoding Rules (<span class=
"smallcaps">der</span>) form of the certificate.”</p>
<p>Technically many hash functions can be used, but webrtc-rs only
supports <span class="oldstyle-num">sha-256</span>; maybe all the
browsers and libraries decide to only use <span class=
"oldstyle-num">sha-256</span>?</p>
<p>For reference, here is how does webrtc-rs hash and validate the
fingerprint: <a href=
"https://github.com/webrtc-rs/webrtc/blob/4bb9614c56131accc47e903eed086b46c9a2e57c/webrtc/src/dtls_transport/mod.rs#L548">
<code>validate_fingerprint</code></a>.</p>
<p>Here’s an example <span class="smallcaps">sdp</span> that contains two
fingerprints. (<code>a</code> means attribute. See <a href=
"https://datatracker.ietf.org/doc/html/rfc8866#name-attributes-a"><span class="oldstyle-num">
<span class="smallcaps">rfc 8866</span></span></a>.) The fingerprint is
produced by first hasing the <span class="smallcaps">der</span>, then
print out each byte in hex, and join them together with colon.</p>
<pre class="code-block">m=image 54111 TCP/TLS t38
c=IN IP4 192.0.2.2
a=setup:passive
a=connection:new
a=fingerprint:SHA-256 \
12:DF:3E:5D:49:6B:19:E5:7C:AB:4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF: \
3E:5D:49:6B:19:E5:7C:AB:4A:AD
a=fingerprint:SHA-1 \
4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB</pre>
<h2 id="Code" class="section">Code</h2>
<p>Knowing how WebRTC works is one thing, knowing how to conjure the
right module and function in the library is another thing. It doesn’t
help that webrtc-rs is relatively thin on documentation. So this section
contains code snippets taken directly from working code, plus reference
to <a href="https://github.com/casouri/collab-mode">my program</a> and
webrtc-rs.</p>
<h3 id="Signaling%20server" class="subsection">Signaling server</h3>
<p>This is not a part of WebRTC, but for completeness I’ll brefly explain
how I wrote my signaling server. There are many articles online about
signaling servers too.</p>
<p>For my signaling server, I used websocket since it allows the client
to receive streams from the server, plus it provides a nice text/binary
message abstraction, making it nicer to use than <span class=
"smallcaps">tcp</span>. I used <a href=
"https://crates.io/crates/tokio-tungstenite">tokio-tungstenite</a> for
websocket.</p>
<p>When a client (say, A) wants to accept connections from other peers,
it sends a <code>Bind</code> message to the signaling server S, along
with an id. Then, another client (say, B) can send a <code>Connect</code>
message to S that asks to connect to A by its id. B’s
<code>Connect</code> message would contain its <span class=
"smallcaps">sdp</span>. S relays B’s <code>Connect</code> message to A,
then A sends its <span class="smallcaps">sdp</span> via a
<code>Connect</code> message to B (relayed by S). Then A and B would
start sending each other <span class="smallcaps">ice</span> candidates
via <code>Candidate</code> message through S. Finally, A and B establish
e2e connection and don’t need S anymore.</p>
<p>My signaling code is in <a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/signaling.rs">
<code>/src/signaling.rs</code></a> and <a href=
"https://github.com/casouri/collab-mode/tree/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/signaling">
<code>/src/signaling</code></a>.</p>
<h3 id="Cargo.toml" class="subsection">Cargo.toml</h3>
<p>Here’s the relevant crates I used and their version:</p>
<div class="highlight">
<pre><code>sha2 = "0.10.8"
pem = "3.0.4"
# Make sure the version of webrtc-util matches the one that's used by
# webrtc-ice, webrtc-sctp, and webrtc-dtls.
webrtc-ice = "0.10.0"
webrtc-util = "0.8.0"
webrtc-sctp = "0.9.0"
webrtc-dtls = "0.8.0"
# Used by webrtc.
bytes = "1.4.0"
# This is the version used by webrtc-dtls.
rcgen = { version = "0.11.1", features = ["pem", "x509-parser"]}
# This is the version used by webrtc-dtls.
rustls = "0.21.10"</code></pre></div>
<h3 id="ICE" class="subsection">ICE</h3>
<p><a href=
"https://docs.rs/webrtc-ice/latest/webrtc_ice/agent/index.html">webrtc_ice
documentation</a>.</p>
<p>Suppose we have two peer A and B; A wants to accept connection from B.
Then A is the server in this situation, and B is the client. In the same
time, both A and B are clients of the signaling server S. To avoid
confusion, let’s call A the <span class="oldstyle-num">p2p</span> server,
B the <span class="oldstyle-num">p2p</span> client, and call A & B the
signaling client.</p>
<p>To start establishing an <span class="smallcaps">ice</span>
connection, we need to create an agent (<a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/webrpc/ice.rs#L146">source</a>):</p>
<div class="highlight">
<pre><code>use std::sync::Arc;
use webrtc_ice::agent::agent_config::AgentConfig;
use webrtc_ice::agent::Agent;
use webrtc_ice::network_type::NetworkType;
use webrtc_ice::udp_network::{EphemeralUDP, UDPNetwork};
use webrtc_ice::url::Url;

let mut config = AgentConfig::default();
// "Controlling" should be true for the initiator (p2p client), false
// for the acceptor (p2p server).
config.is_controlling = false;
config.network_types = vec![NetworkType::Udp4];
config.udp_network = UDPNetwork::Ephemeral(EphemeralUDP::default());
// A list of public STUN servers.
config.urls = vec![
    Url::parse_url("stun:stun1.l.google.com:19302").unwrap(),
    Url::parse_url("stun:stun2.l.google.com:19302").unwrap(),
    Url::parse_url("stun:stun3.l.google.com:19302").unwrap(),
    Url::parse_url("stun:stun4.l.google.com:19302").unwrap(),
    Url::parse_url("stun:stun.nextcloud.com:443").unwrap(),
    Url::parse_url("stun:stun.relay.metered.ca:80").unwrap(),
];
let agent = Arc::new(Agent::new(config));</code></pre></div>
<p>If we were to use WebRTC’s glue layer, we would create a <span class=
"smallcaps">sdp</span> and set two <span class="smallcaps">ice</span>
attributes in it: <code>ufrag</code> and <code>pwd</code>. But since we
aren’t using WebRTC’s glue layer, we just need to get <code>ufrag</code>
and <code>pwd</code> from the <span class="smallcaps">ice</span> agent,
serialize it, and send it through the signaling server. This will be our
version of the <span class="smallcaps">sdp</span>.</p>
<p>Our “<span class="smallcaps">sdp</span>-at-home” also needs to include
the fingerprint. Technically this fingerprint can be in any format you
wish, but I decided to just follow WebRTC’s spec—hash the <span class=
"smallcaps">der</span> version of the public key. Here’s my hash function
(<a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/config_man.rs#L47">source</a>):</p>
<div class="highlight">
<pre><code>use sha2::{Digest, Sha256};
/// Hash the binary DER file and return the hash in fingerprint
/// format: each byte in uppercase hex, separated by colons.
pub fn hash_der(der: &amp;[u8]) -&gt; String {
  let hash = Sha256::digest(der);
  // Separate each byte with colon like webrtc does.
  let bytes: Vec&lt;String&gt; = hash.iter().map(|x| format!("{x:02x}")).collect();
  bytes.join(":").to_uppercase()
}

let fingerprint = hash_der(key_der);
let (ufrag, pwd) = agent.get_local_user_credentials().await;
// Then serialize them and send them over the signaling server.</code></pre></div>
<p>My hash function is mostly the same as <a href=
"https://github.com/webrtc-rs/webrtc/blob/62f2550799efe2dd36cdc950ad3f334b120c75bb/webrtc/src/dtls_transport/mod.rs#L548">
the hash function in webrtc-rs</a>.</p>
<p>Now assume both A and B have their own local <span class=
"smallcaps">sdp</span> (<code>ufrag</code>, <code>pwd</code>, and
<code>fingerprint</code>), and received each other’s <span class=
"smallcaps">sdp</span>. The next step is to exchange <span class=
"smallcaps">ice</span> candidates.</p>
<p>To send out candidates, we register a callback function on
<code>agent</code>, like so (<a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/webrpc/ice.rs#L202">source</a>):</p>
<div class="highlight">
<pre><code>agent.on_candidate(Box::new(move |candidate| {
    if let Some(candidate) = candidate {
        let candidate = candidate.marshal();

        tokio::spawn(async move {
            // Send out candidate through the signaling server.
        });
    }
    Box::pin(async {})
}))

// And start gathering candidates, once the agent got a candidate,
// it’ll invoke the on_candidate callback and our code will send
// it out.
agent.gather_candidates()?;</code></pre></div>
<p>On the other side, we want to receive <span class=
"smallcaps">ice</span> candidates from the signaling server and feed them
into <code>agent</code> (<a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/webrpc/ice.rs#L230">source</a>):</p>
<div class="highlight">
<pre><code>while let Some(candidate) = (receive candidate from signaling server) {
    let candidate = unmarshal_candidate(&amp;candidate)?;
    let candidate: Arc&lt;dyn Candidate + Send + Sync&gt; = Arc::new(candidate);
    agent.add_remote_candidate(&amp;candidate)?;
}</code></pre></div>
<p>While gathering and exchanging candidate run in the background, we
block on <code>agent.accept()</code> (<a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/webrpc/ice.rs#L67">source</a>)
or <code>agent.dial()</code> (<a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/webrpc/ice.rs#L110">source</a>)
to get our connection:</p>
<div class="highlight">
<pre><code>// For p2p server A:
let ice_conn = agent.accept(cancel_rx, ufrag, pwd);
// For p2p client B:
let ice_conn = agent.dial(cancel_rx, ufrag, pwd);</code></pre></div>
<h2 id="DTLS" class="section">DTLS</h2>
<p><a href=
"https://docs.rs/webrtc-dtls/latest/webrtc_dtls/index.html">webrtc_dtls
documentation</a>.</p>
<p>Now we need to setup a <span class="smallcaps">dtls</span> connection
from the <span class="smallcaps">ice</span> connection, and verify the
fingerprint.
<br>
To create a <span class="smallcaps">dtls</span> connection, we need to
pass it the key we used to generate the fingerprint earlier. Suppose
variable <code>key_der: u8[]</code> contains the key in <span class=
"smallcaps">der</span> format, we create the certificate that webrtc_dtls
accepts (<a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/config_man.rs#L31">source</a>):</p>
<div class="highlight">
<pre><code>let dtls_cert = webrtc_dtls::crypto::Certificate {
    certificate: vec![rustls::Certificate(key_der)],
    private_key: webrtc_dtls::crypto::CryptoPrivateKey::from_key_pair(
        &amp;rcgen::KeyPair::from_der(key_der).unwrap(),
    )
        .unwrap(),
};</code></pre></div>
<p>Then create the <span class="smallcaps">dtls</span> connection. For
<span class="oldstyle-num">p2p</span> server, do this (<a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/webrpc.rs#L98">source</a>):</p>
<div class="highlight">
<pre><code>let config = webrtc_dtls::config::Config {
    certificates: vec![dtls_cert],
    client_auth: webrtc_dtls::config::ClientAuthType::RequireAnyClientCert,
    // We accept any certificate, and then verifies the provided
    // certificate with the cert we got from signaling server.
    insecure_skip_verify: true,
    ..Default::default()
};

// Pass false for p2p server.
let dtls_conn = DTLSConn::new(ice_conn, config, false, None).await?;</code></pre></div>
<p>For <span class="oldstyle-num">p2p</span> client, do this (<a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/webrpc.rs#L117">source</a>):</p>
<div class="highlight">
<pre><code>let config = webrtc_dtls::config::Config {
    certificates: vec![dtls_cert],
    // We accept any certificate, and then verifies the provided
    // certificate with the cert we got from signaling server.
    insecure_skip_verify: true,
    ..Default::default()
};

// Pass true for p2p client.
let dtls_conn = DTLSConn::new(ice_conn, config, true, None).await?;</code></pre></div>
<p>Next, on both <span class="oldstyle-num">p2p</span> server and
<span class="oldstyle-num">p2p</span> client, verify the peer certificate
of the <span class="smallcaps">dtls</span> connection matches the
fingerprint we received from the signaling server (we got it along with
<code>ufrag</code> and <code>pwd</code> in the <span class=
"smallcaps">sdp</span>) (<a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/webrpc.rs#L84">source</a>).</p>
<div class="highlight">
<pre><code>let certs = dtls_conn.connection_state().await.peer_certificates;
if certs.is_empty() {
    // Throw error.
}
// hash_der is shown in the previous section.
let peer_cert_hash_from_dtls = hash_der(&amp;certs[0]);;
if peer_cert_hash_from_dtls != cert_hash_from_signaling_server {
    // Throw error.
}</code></pre></div>
<h2 id="SCTP" class="section">SCTP</h2>
<p><a href=
"https://docs.rs/webrtc-sctp/0.10.0/webrtc_sctp/association/index.html">webrtc_sctp
documentation</a>.</p>
<p>We’re getting there! The final step is to setup <span class=
"smallcaps">sctp</span> connection (<a href=
"https://github.com/casouri/collab-mode/blob/e06588294bec25b0b1a6d22ee33cdf4c8c8fd252/src/webrpc.rs#L135">source</a>):</p>
<div class="highlight">
<pre><code>use webrtc_sctp::association;

let assoc_config = association::Config {
    net_conn: dtls_conn,
    name: "whatever".to_string(),
};

// For p2p server:
let assoc_server = association::Association::server(assoc_config).await?;
sctp_connection.accept_stream().await

// For p2p client:
let assoc_client = association::Association::client(assoc_config).await?;
// The stream identifier can be anything (here I used 1).
sctp_conn.open_stream(1, PayloadProtocolIdentifier::Binary).await?</code></pre></div>
<p>Technically, <span class="smallcaps">sctp</span> support both message
and stream, but webrtc-rs only implemented the stream. Fortunately, it
also implemented concurrent streams. So instead of chunking messages
myself, I simply create a new stream for each message and rely on
<span class="smallcaps">sctp</span> to do the chunking. The streams are
technically used for long-lived data transfer, but because it’s
implemented by simple stream-id tags on chunks, creating and destroying
streams doesn’t add much overhead. Just be aware that a new stream
created by yourself also arrives as a new stream to the
<code>accept</code> method, so there needs to be a way to differentiate
between streams opened locally and remotely. I use odd/even stream id to
differentiate.</p>
<h2 id="Conclusion" class="section">Conclusion</h2>
<p>That’s it! Now we have a binary stream between two peers. While
setting everything up, it helps to go one layer at a time, verify it
works, and add the next layer. It also helps to first set it up without
authentication, then add the key verification step.</p>
<h2 id="Appendix%20A,%20a%20rcgen%20pitfall" class="section">Appendix A,
a rcgen pitfall</h2>
<p>Because I fell into this trap using rcgen and spent two whole nights
scratching my head, I want to call it out so readers can avoid it.</p>
<p>Say that you want to generate a certificate and pass it around your
program. The intuitive way is to create a
<code>rcgen::Certificate</code>, pass it around, and call
<code>rcgen::Certificate::serialize_der</code> every time you need a
<span class="smallcaps">der</span>, right? But actually, every time you
call <code>serialize_der</code>, rather than just serializing the
certificate, it <em>generates</em> a new certificate. Put it another way,
every time you call <code>serialize_der</code>, it returns a different
value.</p>
<p>So the correct way to generate a certificate and pass it around is to
create a <code>rcgen::Certificate</code>, call <code>serialize_der</code>
to get the <span class="smallcaps">der</span>, and pass the <span class=
"smallcaps">der</span> around. If you need to use the certificate in
another format, just parse the <span class="smallcaps">der</span>.</p>
<p>Here’s an GitHub issue discussing it: <a href=
"https://github.com/rustls/rcgen/issues/62">Issue#62</a>.</p>
</article>
</main>
<footer id="postamble">
<div>
<p>Written by Yuan Fu</p>
<p>Published on 2024-07-20 Sat</p>
<p>Comment by sending a message to <a href=
"mailto:~casouri/public-inbox@lists.sr.ht?Subject=Re%3A%20Peer-to-peer%20Connection%20with%20WebRTC%20in%20Rust%20Using%20webrtc-rs">
the public inbox</a></p>
<p><a href=
"https://lists.sr.ht/~casouri/public-inbox?search=Peer-to-peer%20Connection%20with%20WebRTC%20in%20Rust%20Using%20webrtc-rs">
View existing discussions</a> | <a href=
"https://man.sr.ht/lists.sr.ht/etiquette.md">Mailing list
etiquette</a></p>
<p><a href="/note/atom.xml">RSS</a> | <a href=
"https://github.com/casouri/casouri.github.io">Source</a> | <a href=
"https://creativecommons.org/licenses/by-sa/4.0/">License</a></p>
</div>
</footer>
</body>
</html>
