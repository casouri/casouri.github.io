#+OPTIONS: html-style:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="/style.css"/>
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="/note/style.css"/>
#+HTML_LINK_UP: /note
#+HTML_LINK_HOME: /note
#+TITLE: Basic Sorting Algorithm
#+DATE: <2018-09-11 Tue>

[[./sort.py][Download python source file]]

*Note:* all images are from [[http://interactivepython.org/courselib/static/pythonds/index.html][iteractive python]].

* Bubble Sort

[[http://interactivepython.org/courselib/static/pythonds/SortSearch/TheBubbleSort.html][REF]]

** Normal bubble

For each pair in the list (1&2, 2&3, 3&4), if the former is greater than latter, swap.
After one pass from 0 to n, the largest number should be in the last position.
Then only n-1 numbers need to be sorted, so it perform another pass from 0 to n-1.

Therefore the time complexity is $O(n^2)$.

[[./bubblepass.png]]

#+BEGIN_SRC python
def bubble(lis):
    for last_num in range(len(lis) - 1, 0, -1):
        for index in range(0, last_num):
            if lis[index] > lis[index + 1]:
                tmp = lis[index]
                lis[index] = lis[index + 1]
                lis[index + 1] = tmp
    return lis


alist = [54, 26, 93, 17, 77, 31, 44, 55, 20]
bubble(alist)
print(alist)
#+END_SRC

** Short bubble

Although bubble sort wastes time swapping, it has a unique character among sorting algorithms:
If it runs a pass without swapping any pair, then the list is already sorted and the program can end early.

That is good for lists that are almost sorted. The list below only need one pass.

#+BEGIN_SRC python
def short_bubble(lis):
    swapped_last_iter = True
    last_num = len(lis) - 1
    iter_count = 0
    while last_num and swapped_last_iter:
        iter_count += 1
        for index in range(0, last_num):
            if lis[index] > lis[index + 1]:
                swapped_last_iter = True
                tmp = lis[index]
                lis[index] = lis[index + 1]
                lis[index + 1] = tmp
            else:
                swapped_last_iter = False
        last_num -= 1
    print(iter_count)

alist = [20, 30, 40, 90, 50, 60, 70, 80, 100, 110]
short_bubble(alist)
print(alist)
#+END_SRC

* Selection Sort

[[http://interactivepython.org/courselib/static/pythonds/SortSearch/TheSelectionSort.html][REF]]

The selection sort improves on the bubble sort by making only one exchange for every pass through the list.
Basically on each pass it looks for the largest number and then insert it in the proper place.

Although the time complexity of selection sort is also $O(n^2)$,
but because it makes much less exchanges, selection sort is usually faster than bubble sort.

[[./selection.png]]

#+BEGIN_SRC python
def selection(lis):
    # note that it's to 1, not 0
    # because we only need to place n to n-1 position
    # then 0 position will be left with the smallest number
    for index_of_last_num in range(len(lis) - 1, 1, -1):
        index_of_max = 0
        # look for max number ('s index)
        for index in range(0, index_of_last_num + 1):
            if lis[index] > lis[index_of_max]:
                index_of_max = index
        # swap
        tmp = lis[index_of_last_num]
        lis[index_of_last_num] = lis[index_of_max]
        lis[index_of_max] = tmp


alist = [54, 26, 93, 17, 77, 31, 44, 55, 20]
selection(alist)
print(alist)
#+END_SRC

* Insertion Sort

[[http://interactivepython.org/courselib/static/pythonds/SortSearch/TheInsertionSort.html][REF]]

The insertion sort, although still $O(n^2)$, uses shifting instead of swapping,
which is more efficient. Insertion sort maintains a sorted list in the beginning of the
list.

It assumes the first item of the list is sorted (sorted one item list),
and then for the 2nd, 3rd, ... item, it shifts the number in the sorted list
to put it into proper position.

[[./insertion.png]]

#+BEGIN_SRC python
def insertion(lis):
    for index_of_moving_num in range(1, len(lis)):
        moving_num = lis[index_of_moving_num]
        # this position is at the end of the sorted list
        position = index_of_moving_num

        # shift forward until reached the beginning of the list
        # or found the right position
        while position > 0 and lis[position - 1] > moving_num:
            # shift the number before back
            lis[position] = lis[position - 1]
            position -= 1

        lis[position] = moving_num


alist = [54, 26, 93, 17, 77, 31, 44, 55, 20]
insertion(alist)
print(alist)
#+END_SRC

* Shell Sort

[[http://interactivepython.org/courselib/static/pythonds/SortSearch/TheShellSort.html][REF]]

Or diminishing increment sort.
It improves insertion sort by breaking a list into several sub lists
and perform insertion sort on them. The key is that instead of breaking the list
into continuous sub lists, shell sort chose a /increment/ =i=, and
choose all items =i= apart into a sub list.

[[./shellsortA.png]]

Then by sorting these sub lists, items are closer to their right position

[[./shellsortB.png]]

After all sub lists are sorted, a final insertion sort sorts everything into position.
Because of the earlier sub list sorting, the final sort requires less shifting.

Shell sort's time complexity often falls somewhere between $O(n)$ and $O(n^2)$.
By changing the increment, for example using $2kâˆ’1$,
(1, 3, 7, 15, 31, and so on), a shell sort can perform at $O(n^\frac{3}{2})$.

#+BEGIN_SRC python
def gap_insertion(lis, start_pos, gap):
    # same as insertion but step by sublist_count instead of 1
    for index in range(start_pos + gap, len(lis), gap):
        moving_num = lis[index]
        position = index
        while position >= gap and lis[position - gap] > moving_num:
            lis[position] = lis[position - gap]
            position = position - gap
        lis[position] = moving_num


def shell(lis):
    sublist_count = len(lis) // 2
    while sublist_count > 0:
        for start_pos in range(sublist_count):
            gap_insertion(lis, start_pos, sublist_count)
        print(
            'Sorted sublists of number %d and list looks like' % sublist_count)
        print(lis)
        sublist_count = sublist_count // 2


alist = [54, 26, 93, 17, 77, 31, 44, 55, 20]
shell(alist)
print(alist)
#+END_SRC

* Merge Sort

[[http://interactivepython.org/courselib/static/pythonds/SortSearch/TheMergeSort.html][REF]]

Merge sort has to stages: in the first stage it recursively subdivides
the list by half until there is only on item in each list;
in the second stage it merges each sublists back and sort them in the same time.

In the first stage the list is subdivided $\log_2 n$ times,
so the time complexity is $O(n \log n)$.



