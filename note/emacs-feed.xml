<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Emacs Notes</title>
  <link href="https://archive.casouri.cc/note" rel="self" />
  <updated>2025-02-21T00:09:00.00-05:00</updated>
  <author>
    <name>Yuan Fu</name>
  </author>
  <icon>https://archive.casouri.cc/favicon.png</icon>
  <id>urn:uuid:53fd03d4-ec1b-11eb-8cca-e7401fdbc2e2</id>
  
  
  <entry><title>Tree-sitter Changes in Emacs 30</title><link href="https://archive.casouri.cc/note/2024/emacs-30-tree-sitter"/><id>urn:uuid:7ca5d6e8-6360-11ef-a7d1-9fc47809e9cf</id><updated>2024-12-16T21:19:00.00-05:00</updated><content type="html">&lt;p&gt;A year has passed since the release of Emacs &lt;span class="oldstyle-num"&gt;29&lt;/span&gt;; last time we added support for tree-sitter and several tree-sitter-based major modes. This time, there are more major modes, better support for multi-language modes, and more utility features.&lt;/p&gt;&lt;p&gt;The first three sections introduce changes visible to end-users, the rest are for package and major mode developers.&lt;/p&gt;&lt;h2 id="Derived%20mode%20check" class="section"&gt;Derived mode check&lt;/h2&gt;&lt;p&gt;Now &lt;code&gt;(derived-mode-p 'c-mode)&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; even in &lt;code&gt;c-ts-mode&lt;/code&gt; (and similarly for other builtin tree-sitter modes). That means &lt;code&gt;.dir-locals.el&lt;/code&gt; settings and yasnippets for &lt;code&gt;c-mode&lt;/code&gt; will work for &lt;code&gt;c-ts-mode&lt;/code&gt; too. However, &lt;code&gt;c-ts-mode&lt;/code&gt; still doesn’t run &lt;code&gt;c-mode&lt;/code&gt;’s major mode hooks. Also, there’s still no major mode fallback. But I think that can be solved by packages like &lt;a href="https://archive.casouri.cc/note/2024/emacs-30-tree-sitter/https:/github.com/renzmann/treesit-auto"&gt;treesit-auto&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;This new inheritance doesn’t come automatically, someone needs to use &lt;code&gt;derived-mode-add-parents&lt;/code&gt; to add the relationship.&lt;/p&gt;&lt;h2 id="New%20major%20modes" class="section"&gt;New major modes&lt;/h2&gt;&lt;p&gt;There are some new built-in major modes: Elixir and HEEx mode, HTML mode, Lua mode, PHP mode with PHPDoc support, and Doxygen support for C/C++/Java mode. Kudos to Wilhelm for writing Elixir and HEEx mode, John for writing Lua mode, and Vincenzo for writing PHP mode and Doxygen support!&lt;/p&gt;&lt;p&gt;HEEx mode and PHP mode really shows the power of tree-sitter: without tree-sitter, it would take a lot of work to write a major mode for mixed languages like these; now tree-sitter takes care of all the hard work, and we can focus on writing the things we care about: font-lock and indentation rules, utility commands, etc.&lt;/p&gt;&lt;p&gt;When Wilhelm and Vincenzo were implementing multi-language major modes, they found bugs and missing features in Emacs and provided invaluable feedback on emacs-devel and the bug tracker. Their feedback and requests allow us to improve Emacs’ support for multi-languages. So if you’re writing a major mode or some package with tree-sitter and run into issues, don’t hesitate to reach out on emacs-devel or the bug tracker!&lt;/p&gt;&lt;h2 id="Sexp%20movement" class="section"&gt;Sexp movement&lt;/h2&gt;&lt;p&gt;I’ll explain it a bit more in the next section, but the gist is that &lt;code&gt;forward-sexp&lt;/code&gt; and &lt;code&gt;backward-sexp&lt;/code&gt; can now use the parse tree for navigation, as long as the major mode adds support for them. Users can also change what’s considered a &lt;code&gt;sexp&lt;/code&gt; (A statement? An expression? Or any node in the parse tree?) themselves, overriding the major mode’s setting.&lt;/p&gt;&lt;h2 id="Defining%20things" class="section"&gt;Defining things&lt;/h2&gt;&lt;p&gt;Sections below are mostly for developers.&lt;/p&gt;&lt;p&gt;In the spirt of &lt;code&gt;thing-at-point&lt;/code&gt;, a major mode or user can now define tree-sitter &lt;em&gt;things&lt;/em&gt;: &lt;code&gt;defun&lt;/code&gt;, &lt;code&gt;sexp&lt;/code&gt;, &lt;code&gt;sentence&lt;/code&gt;, &lt;code&gt;comment&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;block&lt;/code&gt;, etc. The definition is flexible: it can be a regexp matching node names, or a predicate function, or a regexp plus a predicate. It can also be defined with logical operands &lt;code&gt;not&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;, like &lt;code&gt;(not sexp)&lt;/code&gt;, or &lt;code&gt;(not "comment")&lt;/code&gt;, &lt;code&gt;(or comment text)&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;At the moment, the following “standard” things are used by Emacs:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;sexp&lt;/code&gt;: Used by &lt;code&gt;forward-sexp&lt;/code&gt;, etc.&lt;/li&gt;&lt;li&gt;&lt;code&gt;defun&lt;/code&gt;: Used by &lt;code&gt;end-of-defun&lt;/code&gt;, etc.&lt;/li&gt;&lt;li&gt;&lt;code&gt;sentence&lt;/code&gt;: Used by &lt;code&gt;forward-sentence&lt;/code&gt;. In imperative languages, it can be a statement.&lt;/li&gt;&lt;li&gt;&lt;code&gt;comment&lt;/code&gt;: All types of comments.&lt;/li&gt;&lt;li&gt;&lt;code&gt;string&lt;/code&gt;: All types of strings.&lt;/li&gt;&lt;li&gt;&lt;code&gt;text&lt;/code&gt;: Any non-code. Comments, strings, and text in languages HTML and jsx.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Like font-lock features, we’re starting with a basic list; if you have suggestions fore more things (perhaps you wrote a package that uses a thing that major modes should support), reach out on emacs-devel or debbugs.&lt;/p&gt;&lt;p&gt;Tree-sitter things are supported in every tree-sitter function . Once the major mode defines it, everyone can use it. Here are some things you can do with it:&lt;/p&gt;&lt;p&gt;Get the sexp at point &lt;a id="footref:in-any-mode" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Ain-any-mode"&gt;in any tree-sitter major mode&lt;sup class="inline-footref"&gt;1&lt;/sup&gt;&lt;/a&gt;: &lt;code&gt;(treesit-thing-at-point 'sexp 'nested)&lt;/code&gt;. Get the sexp before point: &lt;code&gt;(treesit-thing-prev (point) 'sexp)&lt;/code&gt;.&lt;/p&gt;&lt;div id="footdef:in-any-mode" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Ain-any-mode"&gt;1&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;Provided that the mode defined the thing.&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Generate a tree of all the defuns in a buffer:&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-induce-sparse-tree
 (treesit-buffer-root-node)
 'defun)&lt;/pre&gt;&lt;p&gt;Traverse things:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;treesit-beginning-of-thing&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;treesit-end-of-thing&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;treesit-navigate-thing&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I can also see packages reserving a particular thing, and have major modes add definition for that thing. In that case, it’s best to add the package prefix to avoid naming conflict.&lt;/p&gt;&lt;h2 id="Local%20parsers" class="section"&gt;Local parsers&lt;/h2&gt;&lt;p&gt;Normally, even for the embedded language, there’s only one parser for that language in a buffer. Each individual embedded code block are “stitched together” and is parsed as a whole by that parser. The pro is we only need to create one parser, the cons are error in one code block might affect other code blocks, and sometimes, each code block is syntactically self-contained and shouldn’t be stitched with others.&lt;/p&gt;&lt;p&gt;That’s why we added local parsers, with each one confined to a single code block. Emacs creates and manages parsers for each embedded code block automatically. PHPDoc and Doxygen support are possible thanks to local parsers. To use local parsers, simply add the &lt;code&gt;:local t&lt;/code&gt; flag in &lt;code&gt;treesit-range-rules&lt;/code&gt;, and Emacs handles the rest.&lt;/p&gt;&lt;h2 id="Other%20changes" class="section"&gt;Other changes&lt;/h2&gt;&lt;p&gt;A small convenience improvement: &lt;code&gt;treesit-font-lock-rules&lt;/code&gt; now supports the &lt;code&gt;:default-language&lt;/code&gt; keyword, so major mode author don’t need to write &lt;code&gt;:language 'xxx&lt;/code&gt; for every query anymore.&lt;/p&gt;&lt;p&gt;Each parser in the parser list now has a tag. By default, a parser has the &lt;code&gt;nil&lt;/code&gt; tag, and &lt;code&gt;(treesit-parser-list)&lt;/code&gt; returns all the parsers with &lt;code&gt;nil&lt;/code&gt; tag (because the third optional argument &lt;code&gt;TAG&lt;/code&gt; defaults to &lt;code&gt;nil&lt;/code&gt;). That means if you don’t explicitly set a tag when creating a parser, it’ll show up when anyone calls &lt;code&gt;(treesit-parser-list)&lt;/code&gt;. On the other hand, you can create a parser that doesn’t show up in the parser list if you give it a non-nil tag. The intended use-case is to create special purpose parsers that shouldn’t normally appear in the parser list.&lt;/p&gt;&lt;p&gt;Local parsers has the &lt;code&gt;embedded&lt;/code&gt; tag, so they don’t appear in the parser list. You can get them by passing &lt;code&gt;embedded&lt;/code&gt; to the &lt;code&gt;TAG&lt;/code&gt; argument, or by passing the special value &lt;code&gt;t&lt;/code&gt; to the &lt;code&gt;TAG&lt;/code&gt; argument, which means return all parsers regardless of their tag.&lt;/p&gt;&lt;p&gt;Indirect buffers now gets individual parser lists. In Emacs 29, the origin buffer and all its indirect buffers share the same parser list. Now they each have their own parser list.&lt;/p&gt;&lt;h2 id="Better%20filling%20for%20C-style%20comment%20blocks" class="section"&gt;Better filling for C-style comment blocks&lt;/h2&gt;&lt;p&gt;This is not directly related to tree-sitter but it affects tree-sitter modes for all C-like languages. You see, all these tree-sitter major modes (C, C++, Java, Rust, Javascript, Typescript) uses C-style comment blocks, and they all use &lt;code&gt;c-ts-common.el&lt;/code&gt; for things like filling the comment block, or setting up &lt;code&gt;comment-start&lt;/code&gt;, etc.&lt;/p&gt;&lt;p&gt;Traditionally these kind of major modes use cc-mode’s utilities, but cc-mode is a beast on its own, and it’s not worth it to add that dependency for filling a comment block. (It’s not just code dependency, but also cc-mode’s own parsing facility, data structure, etc.) So we had to recreate these utilities in &lt;code&gt;c-ts-common.el&lt;/code&gt;, with the bonus goal of keeping the code as easy to read as possible.&lt;/p&gt;&lt;p&gt;Filling C-style comment block is harder than one might imagine. It’s quite involved and interesting, and worth a separate article on its own. Suffice to say that the filling logic is improved and works on even more styles of C comment blocks now. Below are a few among the ones that we support.&lt;/p&gt;&lt;pre class="code-block"&gt;/* xxx  /**    /* xxx
 * xxx   * xxx    xxx
 */      */       xxx */

/*======  /*
 * xxx     | xxx
 *======/  */&lt;/pre&gt;&lt;p&gt;And it goes beyond just filling, when you type return in a comment block, you expect the next line to be prefixed with some character (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt; or space) and indented to the right place. Making that work for all those styles on top of the filling and keeping the code reasonably readable is a small miracle :-)&lt;/p&gt;&lt;h2 id="Primary%20parser" class="section"&gt;Primary parser&lt;/h2&gt;&lt;p&gt;If you are the author of a tree-sitter major mode, make sure to set &lt;code&gt;treesit-primary-parser&lt;/code&gt; in your major mode if it has multiple languages! This is a new variable added in Emacs &lt;span class="oldstyle-num"&gt;30&lt;/span&gt;, and setting it is vital for font-lock update to work properly in complex situations. Emacs makes a reasonable guess when the major mode doesn’t set it themselves (it sets the first parser in the parser list as the primary parser). But this guess doesn’t work reliably for multi-language major modes.&lt;/p&gt;&lt;p&gt;Besides Emacs itself, other packages can also make use of this variable. It’ll be better than &lt;code&gt;(car (treesit-parser-list))&lt;/code&gt;, especially in multi-language modes.&lt;/p&gt;&lt;p&gt;Having an explicit primary parser allows Emacs to update the “changed region” after each buffer change correctly, especially for multi-language modes. For example, when the user types the closing block comment delimiter &lt;code&gt;*/&lt;/code&gt;, not only does Emacs fontify the &lt;code&gt;*/&lt;/code&gt; itself, it also needs to re-fontify the whole block comment, which previously weren’t fontified in comment face due to incomplete parse tree. You can read more about it in &lt;code&gt;treesit--font-lock-mark-ranges-to-fontify&lt;/code&gt; and &lt;code&gt;treesit--pre-redisplay&lt;/code&gt;.&lt;/p&gt;&lt;h2 id="Ready%20your%20major%20mode%20for%20Emacs%2030" class="section"&gt;Ready your major mode for Emacs 30&lt;/h2&gt;&lt;p&gt;Here’s a check list:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Define &lt;code&gt;treesit-primary-parser&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;Define things in &lt;code&gt;treesit-thing-settings&lt;/code&gt;, especially &lt;code&gt;sexp&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Err, that list is shorter than I thought. But I do have some more words for &lt;code&gt;sexp&lt;/code&gt; thing.&lt;/p&gt;&lt;p&gt;There are multiple ways of defining the &lt;code&gt;sexp&lt;/code&gt; thing, you can define it to any node (excluding some punctuation marks), or repeatable node (function arguments, list elements, statements, blocks, defun), or a hand-crafted list of nodes.&lt;/p&gt;&lt;p&gt;Defining &lt;code&gt;sexp&lt;/code&gt; as every node (excluding punctuation) could be a good starting point. For example, this is the definition for &lt;code&gt;sexp&lt;/code&gt; in &lt;code&gt;c-ts-mode&lt;/code&gt;:&lt;/p&gt;&lt;pre class="code-block"&gt;(not ,(rx (or "{" "}" "[" "]" "(" ")" ",")))&lt;/pre&gt;&lt;p&gt;This way, if point is at the beginning of any thing, C-M-f will bring me to the end of that thing, be it an expression, statement, function, block, or whatever. I use it all the time and it’s very handy for selecting code.&lt;/p&gt;&lt;p&gt;&lt;a id="footref:sexp-list" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Asexp-list"&gt;A slight upgrade&lt;sup class="inline-footref"&gt;2&lt;/sup&gt;&lt;/a&gt; from this is to define &lt;code&gt;sexp&lt;/code&gt; to anything that’s repeatable. That takes a bit more effort but C-M-f will always move you to the end of a repeatable construct. This is more inline with the concept of sexp, where we consider each repeatable construct in the code as an atom.&lt;/p&gt;&lt;div id="footdef:sexp-list" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Asexp-list"&gt;2&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;This is just my personal opinion, of course. “Everything is a sexp” might as well be better, since you can move over more types of things.&lt;/div&gt;&lt;/div&gt;&lt;h2 id="Emacs%2031" class="section"&gt;Emacs 31&lt;/h2&gt;&lt;p&gt;At this point we have pretty good support for writing major modes with tree-sitter. Many tree-sitter major modes and packages appeared after Emacs &lt;span class="oldstyle-num"&gt;29&lt;/span&gt; and it’s very encouraging. We’ll continue making it easier to write major modes with tree-sitter, and make it easier to use and configure tree-sitter modes. For example, we’ll add a baseline indentation rule, so major mode authors need to write less indentation rules. And there’re some upgrades to the sexp movement, too.&lt;/p&gt;&lt;p&gt;There are still some unsolved issues. The lack of versioning for language grammars breaks major modes from time to time; installing tree-sitter grammar is not very easy; tree-sitter library still has bugs that results in incorrect parse tree or even causes Emacs to hang. These will be resolved, albeit slowly.&lt;/p&gt;&lt;p&gt;That’s about it! Emacs has been making good progress regarding tree-sitter. And as I said last time, tree-sitter is a really good way to start contributing to Emacs. We’ve seen folks adding their tree-sitter modes into Emacs, you could be the next! Also, many existing builtin major modes lacks utiliy functions that usually come with a major mode. If you see missing feature in a mode, feel free to send a patch!&lt;/p&gt;&lt;p&gt;Ok folks, stay tuned for the next update for Emacs &lt;span class="oldstyle-num"&gt;31&lt;/span&gt;, and feel free to reach out in the meantime!&lt;/p&gt;</content></entry>
  <entry><title>Tree-sitter Starter Guide</title><link href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide"/><id>urn:uuid:afb76ba2-8a39-11ed-998c-8f06c8e638dc</id><updated>2023-01-15T00:00:00.00-05:00</updated><content type="html">&lt;p&gt;This guide gives you a starting point on writing a tree-sitter major mode. Remember, don’t panic and check your manuals!&lt;/p&gt;&lt;h2 id="Build%20Emacs%20with%20tree-sitter" class="section"&gt;Build Emacs with tree-sitter&lt;/h2&gt;&lt;p&gt;You can either install tree-sitter by your package manager, or from&lt;br/&gt;source:&lt;/p&gt;&lt;pre class="code-block"&gt;git clone https://github.com/tree-sitter/tree-sitter.git
cd tree-sitter
make
make install&lt;/pre&gt;&lt;p&gt;To build and run Emacs 29:&lt;/p&gt;&lt;pre class="code-block"&gt;git clone https://git.savannah.gnu.org/git/emacs.git -b emacs-29
cd emacs
./autogen.sh
./configure
make
src/emacs&lt;/pre&gt;&lt;p&gt;Require the tree-sitter package with &lt;code&gt;(require 'treesit)&lt;/code&gt;. Note that tree-sitter always appear as &lt;code&gt;treesit&lt;/code&gt; in symbols. Now check if Emacs is successfully built with tree-sitter library by evaluating &lt;code&gt;(treesit-available-p)&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Tree-sitter stuff in Emacs can be categorized into two parts: the tree-sitter API itself, and integration with fontification, indentation, Imenu, etc. You can use shortdoc to glance over all the tree-sitter API functions by typing &lt;code&gt;M-x shortdoc RET treesit RET&lt;/code&gt;. The integration are described in the rest of the post.&lt;/p&gt;&lt;h2 id="Install%20language%20definitions" class="section"&gt;Install language definitions&lt;/h2&gt;&lt;p&gt;Tree-sitter by itself doesn’t know how to parse any particular language. It needs the language grammar (a dynamic library) for a language to be able to parse it.&lt;/p&gt;&lt;p&gt;First, find the repository for the language grammar, eg, &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/https:/github.com/tree-sitter/tree-sitter-python"&gt;tree-sitter-python&lt;/a&gt;. Take note of the Git clone URL of it, eg, &lt;code&gt;https://github.com/tree-sitter/tree-sitter-python.git&lt;/code&gt;. Now check where is the parser.c file in that repository, usually it’s in &lt;code&gt;src&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Make sure you have Git, C and C++ compiler, and run the &lt;code&gt;treesit-install-grammar&lt;/code&gt; command, it will prompt for the URL and the directory of parser.c, leave other prompts at default unless you know what you are doing.&lt;/p&gt;&lt;p&gt;You can also manually clone the repository and compile it, and put the dynamic library at a standard library location. Emacs will be able to find it. If you wish to put it somewhere else, set &lt;code&gt;treesit-extra-load-path&lt;/code&gt; so Emacs can find it.&lt;/p&gt;&lt;h2 id="Tree-sitter%20major%20modes" class="section"&gt;Tree-sitter major modes&lt;/h2&gt;&lt;p&gt;Tree-sitter modes should be separate major modes, usually named &lt;code&gt;xxx-ts-mode&lt;/code&gt;. I know I said tree-sitter always appear as &lt;code&gt;treesit&lt;/code&gt; in symbols, this is the only exception.&lt;/p&gt;&lt;p&gt;If the tree-sitter mode and the “native” mode could share some setup code, you can create a “base mode”, which only contains the common setup.  For example, there is python-base-mode (shared), and both python-mode (native), and python-ts-mode (tree-sitter) derives from it.&lt;/p&gt;&lt;p&gt;In the tree-sitter mode, check if we can use tree-sitter with &lt;code&gt;treesit-ready-p&lt;/code&gt;, it will emit a warning if tree-sitter is not ready (tree-sitter not built with Emacs, can’t find the language grammar, buffer too large, etc).&lt;/p&gt;&lt;h2 id="Fontification" class="section"&gt;Fontification&lt;/h2&gt;&lt;p&gt;Tree-sitter works like this: It parses the buffer and produces a &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/https:/en.wikipedia.org/wiki/Parse_tree"&gt;&lt;em&gt;parse tree&lt;/em&gt;&lt;/a&gt;. You provide a query made of patterns and capture names, tree-sitter finds the nodes that match these patterns, tag the corresponding capture names onto the nodes and return them to you. The query function returns a list of &lt;code&gt;(capture-name . node)&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;For fontification, we simply use face names as capture names. And the captured node will be fontified in their capture name (the face).&lt;/p&gt;&lt;p&gt;The capture name could also be a function, in which case &lt;code&gt;(NODE OVERRIDE START END)&lt;/code&gt; is passed to the function for fontification. &lt;code&gt;START&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; are the start and end of the region to be fontified.  The function should only fontify within that region.  The function should also allow more optional arguments with &lt;code&gt;&amp;amp;rest _&lt;/code&gt;, for future extensibility.  For &lt;code&gt;OVERRIDE&lt;/code&gt; check out the docstring of &lt;code&gt;treesit-font-lock-rules&lt;/code&gt;.&lt;/p&gt;&lt;h3 id="Query%20syntax" class="subsection"&gt;Query syntax&lt;/h3&gt;&lt;p&gt;There are two types of nodes: “named nodes”, like &lt;code&gt;(identifier)&lt;/code&gt;, &lt;code&gt;(function_definition)&lt;/code&gt;, and “anonymous nodes”, like &lt;code&gt;"return"&lt;/code&gt;, &lt;code&gt;"def"&lt;/code&gt;, &lt;code&gt;"("&lt;/code&gt;, &lt;code&gt;";"&lt;/code&gt;. Parent-child relationship is expressed as&lt;/p&gt;&lt;pre class="code-block"&gt;(parent (child) (child) (child (grand_child)))&lt;/pre&gt;&lt;p&gt;Eg, an argument list &lt;code&gt;(1, "3", 1)&lt;/code&gt; would be:&lt;/p&gt;&lt;pre class="code-block"&gt;(argument_list "(" (number) (string) (number) ")")&lt;/pre&gt;&lt;p&gt;Children could have field names:&lt;/p&gt;&lt;pre class="code-block"&gt;(function_definition name: (identifier) type: (identifier))&lt;/pre&gt;&lt;p&gt;To match any one in the list:&lt;/p&gt;&lt;pre class="code-block"&gt;["true" "false" "none"]&lt;/pre&gt;&lt;p&gt;Capture names can come after any node in the pattern:&lt;/p&gt;&lt;pre class="code-block"&gt;(parent (child) @child) @parent&lt;/pre&gt;&lt;p&gt;The query above captures both the parent and the child.&lt;/p&gt;&lt;p&gt;The query below captures all the keywords with capture name&lt;br/&gt;&lt;code&gt;"keyword"&lt;/code&gt;:&lt;/p&gt;&lt;pre class="code-block"&gt;["return" "continue" "break"] @keyword&lt;/pre&gt;&lt;p&gt;These are the common syntax, check out the full syntax in the manual: &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/html-manual/Pattern-Matching.html"&gt;Pattern Matching&lt;/a&gt;.&lt;/p&gt;&lt;h3 id="Query%20references" class="subsection"&gt;Query references&lt;/h3&gt;&lt;p&gt;But how do one come up with the queries? Take python for an example, open any python source file, type &lt;code&gt;M-x treesit-explore-mode RET&lt;/code&gt;.  You should see the parse tree in a separate window, automatically updated as you select text or edit the buffer.  Besides this, you can consult the grammar of the language definition. For example, Python’s grammar file is at&lt;/p&gt;&lt;p&gt;&lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/https:/github.com/tree-sitter/tree-sitter-python/blob/master/grammar.js"&gt;https://github.com/tree-sitter/tree-sitter-python/blob/master/grammar.js&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Neovim also has a bunch of &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/https:/github.com/nvim-treesitter/nvim-treesitter/tree/master/queries"&gt;queries to reference from&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The manual explains how to read grammar files in the bottom of &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/html-manual/Language-Grammar.html"&gt;Language Grammar&lt;/a&gt;.&lt;/p&gt;&lt;h3 id="Debugging%20queries" class="subsection"&gt;Debugging queries&lt;/h3&gt;&lt;p&gt;If your query has problems, use &lt;code&gt;treesit-query-validate&lt;/code&gt; to debug the query. It will pop a buffer containing the query (in text format) and mark the offending part in red. Set &lt;code&gt;treesit--font-lock-verbose&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; if you want the font-lock function to report what it’s doing.&lt;/p&gt;&lt;h3 id="Set%20up%20font-lock" class="subsection"&gt;Set up font-lock&lt;/h3&gt;&lt;p&gt;To enable tree-sitter font-lock, set &lt;code&gt;treesit-font-lock-settings&lt;/code&gt; and &lt;code&gt;treesit-font-lock-feature-list&lt;/code&gt; buffer-locally and call &lt;code&gt;treesit-major-mode-setup&lt;/code&gt;. For example, see &lt;code&gt;python--treesit-settings&lt;/code&gt; in python.el. Below is a snippet of it.&lt;/p&gt;&lt;p&gt;Note that like the current font-lock system, if the to-be-fontified region already has a face (ie, an earlier match fontified part/all of the region), the new face is discarded rather than applied. If you want later matches always override earlier matches, use the &lt;code&gt;:override&lt;/code&gt; keyword.&lt;/p&gt;&lt;p&gt;Each rule should have a &lt;code&gt;:feature&lt;/code&gt;, like &lt;code&gt;function-name&lt;/code&gt;, &lt;code&gt;string-interpolation&lt;/code&gt;, &lt;code&gt;builtin&lt;/code&gt;, etc. This way users can enable/disable each feature individually.&lt;/p&gt;&lt;p&gt;Read the manual section &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/html-manual/Parser_002dbased-Font-Lock.html"&gt;Parser-based Font-Lock&lt;/a&gt; for more detail.&lt;/p&gt;&lt;p&gt;Example from python.el:&lt;/p&gt;&lt;pre class="code-block"&gt;(defvar python--treesit-settings
  (treesit-font-lock-rules
   :feature 'comment
   :language 'python
   '((comment) @font-lock-comment-face)

   :feature 'string
   :language 'python
   '((string) @python--treesit-fontify-string)

   :feature 'string-interpolation
   :language 'python
   :override t
   '((interpolation (identifier) @font-lock-variable-name-face))

   ...))&lt;/pre&gt;&lt;p&gt;In &lt;code&gt;python-ts-mode&lt;/code&gt;:&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-parser-create 'python)
(setq-local treesit-font-lock-settings python--treesit-settings)
(setq-local treesit-font-lock-feature-list
                '(( comment definition)
                  ( keyword string type)
                  ( assignment builtin constant decorator
                    escape-sequence number property string-interpolation )
                  ( bracket delimiter function operator variable)))
...
(treesit-major-mode-setup)&lt;/pre&gt;&lt;p&gt;Concretely, something like this:&lt;/p&gt;&lt;pre class="code-block"&gt;(define-derived-mode python-ts-mode python-base-mode "Python"
  "Major mode for editing Python files, using tree-sitter library.

\\{python-ts-mode-map}"
  :syntax-table python-mode-syntax-table
  (when (treesit-ready-p 'python)
    (treesit-parser-create 'python)
    (setq-local treesit-font-lock-feature-list
                '(( comment definition)
                  ( keyword string type)
                  ( assignment builtin constant decorator
                    escape-sequence number property string-interpolation )
                  ( bracket delimiter function operator variable)))
    (setq-local treesit-font-lock-settings python--treesit-settings)
    (setq-local imenu-create-index-function
                #'python-imenu-treesit-create-index)
    (setq-local treesit-defun-type-regexp (rx (or "function" "class")
                                              "_definition"))
    (setq-local treesit-defun-name-function
                #'python--treesit-defun-name)
    (treesit-major-mode-setup)

    (when python-indent-guess-indent-offset
      (python-indent-guess-indent-offset))))&lt;/pre&gt;&lt;h2 id="Indentation" class="section"&gt;Indentation&lt;/h2&gt;&lt;p&gt;Indentation works like this: We have a bunch of rules that look like&lt;/p&gt;&lt;pre class="code-block"&gt;(MATCHER ANCHOR OFFSET)&lt;/pre&gt;&lt;p&gt;When the indenting a line, let &lt;code&gt;NODE&lt;/code&gt; be the node at the beginning of the current line, we pass this node to the &lt;code&gt;MATCHER&lt;/code&gt; of each rule, one of them will match the node (eg, “this node is a closing bracket!”). Then we pass the node to the &lt;code&gt;ANCHOR&lt;/code&gt;, which returns a point (eg, the beginning of &lt;code&gt;NODE&lt;/code&gt;’s parent). We find the column number of that point (eg, 4), add &lt;code&gt;OFFSET&lt;/code&gt; to it (eg, 0), and that is the column we want to indent the current line to (4 + 0 = 4).&lt;/p&gt;&lt;p&gt;Matchers and anchors are functions that takes &lt;code&gt;(NODE PARENT BOL &amp;amp;rest _)&lt;/code&gt;. Matches return nil/non-nil for no match/match, and anchors return the anchor point. An Offset is usually a number or a variable, but it can also be a function. Below are some convenient builtin matchers and anchors.&lt;/p&gt;&lt;p&gt;For &lt;code&gt;MATHCER&lt;/code&gt; we have&lt;/p&gt;&lt;pre class="code-block"&gt;(parent-is TYPE) =&amp;gt; matches if PARENT’s type matches TYPE as regexp
(node-is TYPE) =&amp;gt; matches NODE’s type
(query QUERY) =&amp;gt; matches if querying PARENT with QUERY
                 captures NODE.

(match NODE-TYPE PARENT-TYPE NODE-FIELD
       NODE-INDEX-MIN NODE-INDEX-MAX)

=&amp;gt; checks everything. If an argument is nil, don’t match that. Eg,
(match nil TYPE) is the same as (parent-is TYPE)&lt;/pre&gt;&lt;p&gt;For &lt;code&gt;ANCHOR&lt;/code&gt; we have&lt;/p&gt;&lt;pre class="code-block"&gt;first-sibling =&amp;gt; start of the first sibling
parent =&amp;gt; start of parent
parent-bol =&amp;gt; BOL of the line parent is on.
prev-sibling =&amp;gt; start of previous sibling
no-indent =&amp;gt; current position (don’t indent)
prev-line =&amp;gt; start of previous line&lt;/pre&gt;&lt;p&gt;There is also a manual section for indent: &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/html-manual/Parser_002dbased-Indentation.html"&gt;Parser-based Indentation&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;When writing indent rules, you can use &lt;code&gt;treesit-check-indent&lt;/code&gt; to&lt;br/&gt;check if your indentation is correct. To debug what went wrong, set&lt;br/&gt;&lt;code&gt;treesit--indent-verbose&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt;. Then when you indent, Emacs&lt;br/&gt;tells you which rule is applied in the echo area.&lt;/p&gt;&lt;p&gt;Here is an example:&lt;/p&gt;&lt;pre class="code-block"&gt;(defvar typescript-mode-indent-rules
  (let ((offset 'typescript-indent-offset))
    `((typescript
       ;; This rule matches if node at point is ")", ANCHOR is the
       ;; parent node’s BOL, and offset is 0.
       ((node-is ")") parent-bol 0)
       ((node-is "]") parent-bol 0)
       ((node-is "&amp;gt;") parent-bol 0)
       ((node-is "\\.") parent-bol ,offset)
       ((parent-is "ternary_expression") parent-bol ,offset)
       ((parent-is "named_imports") parent-bol ,offset)
       ((parent-is "statement_block") parent-bol ,offset)
       ((parent-is "type_arguments") parent-bol ,offset)
       ((parent-is "variable_declarator") parent-bol ,offset)
       ((parent-is "arguments") parent-bol ,offset)
       ((parent-is "array") parent-bol ,offset)
       ((parent-is "formal_parameters") parent-bol ,offset)
       ((parent-is "template_substitution") parent-bol ,offset)
       ((parent-is "object_pattern") parent-bol ,offset)
       ((parent-is "object") parent-bol ,offset)
       ((parent-is "object_type") parent-bol ,offset)
       ((parent-is "enum_body") parent-bol ,offset)
       ((parent-is "arrow_function") parent-bol ,offset)
       ((parent-is "parenthesized_expression") parent-bol ,offset)
       ...))))&lt;/pre&gt;&lt;p&gt;Then you set &lt;code&gt;treesit-simple-indent-rules&lt;/code&gt; to your rules, and call &lt;code&gt;treesit-major-mode-setup&lt;/code&gt;.&lt;/p&gt;&lt;h2 id="Imenu" class="section"&gt;Imenu&lt;/h2&gt;&lt;p&gt;Set &lt;code&gt;treesit-simple-imenu-settings&lt;/code&gt; and call &lt;code&gt;treesit-major-mode-setup&lt;/code&gt;.&lt;/p&gt;&lt;h2 id="Navigation" class="section"&gt;Navigation&lt;/h2&gt;&lt;p&gt;Set &lt;code&gt;treesit-defun-type-regexp&lt;/code&gt;, &lt;code&gt;treesit-defun-name-function&lt;/code&gt;, and call &lt;code&gt;treesit-major-mode-setup&lt;/code&gt;.&lt;/p&gt;&lt;h2 id="C-like%20languages" class="section"&gt;C-like languages&lt;/h2&gt;&lt;p&gt;[Update: Common functions described in this section have been moved from c-ts-mode.el to c-ts-common.el. I also made some changes to the functions and variables themselves.]&lt;/p&gt;&lt;p&gt;c-ts-common.el has some goodies for handling indenting and filling block comments.&lt;/p&gt;&lt;p&gt;These two rules should take care of indenting block comments.&lt;/p&gt;&lt;pre class="code-block"&gt;((and (parent-is "comment") c-ts-common-looking-at-star)
 c-ts-common-comment-start-after-first-star -1)
((parent-is "comment") prev-adaptive-prefix 0)&lt;/pre&gt;&lt;p&gt;&lt;code&gt;standalone-parent&lt;/code&gt; should be enough for most of the cases where you want to "indent one level further", for example, a statement inside a block. Normally &lt;code&gt;standalone-parent&lt;/code&gt; returns the parent’s start position as the anchor, but if the parent doesn’t start on its own line, it returns the parent’s parent instead, and so on and so forth. This works pretty well in practice. For example, indentation rules for statements and brackets would look like:&lt;/p&gt;&lt;pre class="code-block"&gt;;; Statements in {} block.
((parent-is "compound_statement") standalone-parent x-mode-indent-offset)
;; Closing bracket.
((node-is "}") standalone-parent x-mode-indent-offset)
;; Opening bracket.
((node-is "compound_statement") standalone-parent x-mode-indent-offset)&lt;/pre&gt;&lt;p&gt;You’ll need additional rules for “brackless” if/for/while statements, eg&lt;/p&gt;&lt;pre class="code-block"&gt;if (true)
  return 0;
else
  return 1;&lt;/pre&gt;&lt;p&gt;You need rules like these:&lt;/p&gt;&lt;pre class="code-block"&gt;((parent-is "if_statement") standalone-parent x-mode-indent-offset)&lt;/pre&gt;&lt;p&gt;Finally, &lt;code&gt;c-ts-common-comment-setup&lt;/code&gt; will set up comment and filling for you.&lt;/p&gt;&lt;h2 id="Multi-language%20modes" class="section"&gt;Multi-language modes&lt;/h2&gt;&lt;p&gt;Refer to the manual: &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-starter-guide/html-manual/Multiple-Languages.html"&gt;Multiple Languages&lt;/a&gt;.&lt;/p&gt;&lt;h2 id="Common%20Tasks" class="section"&gt;Common Tasks&lt;/h2&gt;&lt;p&gt;&lt;code&gt;M-x shortdoc RET treesit RET&lt;/code&gt; will give you a complete list.&lt;/p&gt;&lt;p&gt;How to...&lt;/p&gt;&lt;p&gt;&lt;b&gt;Get the buffer text corresponding to a node?&lt;/b&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-node-text node)&lt;/pre&gt;&lt;p&gt;Don’t confuse this with &lt;code&gt;treesit-node-string&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;b&gt;Scan the whole tree for stuff?&lt;/b&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-search-subtree)
(treesit-search-forward)
(treesit-induce-sparse-tree)&lt;/pre&gt;&lt;p&gt;&lt;b&gt;Find/move to to next node that...?&lt;/b&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-search-forward node ...)
(treesit-search-forward-goto node ...)&lt;/pre&gt;&lt;p&gt;&lt;b&gt;Get the root node?&lt;/b&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-buffer-root-node)&lt;/pre&gt;&lt;p&gt;&lt;b&gt;Get the node at point?&lt;/b&gt;&lt;/p&gt;&lt;pre class="code-block"&gt;(treesit-node-at (point))&lt;/pre&gt;</content></entry>
  <entry><title>Tree-sitter in Emacs 29 and Beyond</title><link href="https://archive.casouri.cc/note/2023/tree-sitter-in-emacs-29"/><id>urn:uuid:fac62c4a-8599-11ed-a0db-5f97535421d3</id><updated>2023-01-15T00:00:00.00-05:00</updated><content type="html">&lt;p&gt;Emacs’ release branch is now on complete feature freeze, meaning absolutely only bug fixes can happen on it. Now is a good time to talk about the state of &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-in-emacs-29/https:/tree-sitter.github.io/tree-sitter"&gt;tree-sitter&lt;/a&gt; in Emacs: what do you get in Emacs 29, what you don’t, and what would happen going forward.&lt;/p&gt;&lt;h2 id="What%E2%80%99s%20in%20Emacs%2029" class="section"&gt;What’s in Emacs 29&lt;/h2&gt;&lt;p&gt;From a pure user’s perspective, Emacs 29 just adds some new built-in major modes which look more-or-less identical to the old ones. There aren’t any flashy cool features either. That sounds disappointing, but there are a lot of new stuff under the hood, a solid base upon which exciting things can emerge.&lt;/p&gt;&lt;p&gt;If Emacs 29 is built with the tree-sitter library, you have access to most of the functions in its C API, including creating parsers, parsing text, retrieving nodes from the parse tree, finding the parent/child/sibling node, pattern matching nodes with a DSL, etc. You also get a bunch of convenient functions built upon the primitive functions, like searching for a particular node in the parse tree, cherry picking nodes and building a sparse tree out of the parse tree, getting the node at point, etc. You can type &lt;code&gt;M-x shortdoc RET treesit RET&lt;/code&gt; to view a list of tree-sitter functions. And because it’s Emacs, there is comprehensive manual coverage for everything you need to know. It’s in “Section 37, Parsing Program Source” of Emacs Lisp Reference Manual.&lt;/p&gt;&lt;p&gt;Emacs 29 has built-in tree-sitter major modes for C, C++, C#, Java, Rust, Go, Python, Javascript, Typescript, JSON, YAML, TOML, CSS, Bash, Dockerfile, CMake file. We tried to extend existing modes with tree-sitter at first but it didn’t work out too well, so now tree-sitter lives in separate major modes. The tree-sitter modes are usually called &lt;code&gt;xxx-ts-mode&lt;/code&gt;, like &lt;code&gt;c-ts-mode&lt;/code&gt; and &lt;code&gt;python-ts-mode&lt;/code&gt;. The simplest way to enable them is to use &lt;code&gt;major-mode-remap-alist&lt;/code&gt;. For example,&lt;/p&gt;&lt;pre class="code-block"&gt;(add-to-list 'major-mode-remap-alist
             '(c-mode . c-ts-mode))&lt;/pre&gt;&lt;p&gt;The built-in tree-sitter major modes have support for font-lock (syntax highlight), indentation, Imenu, which-func, and defun navigation.&lt;/p&gt;&lt;p&gt;For major mode developers, Emacs 29 includes integration for these features for tree-sitter, so major modes only need to supply language-specific information, and Emacs takes care of plugging tree-sitter into font-lock, indent, Imenu, etc.&lt;/p&gt;&lt;h3 id="Fontification" class="subsection"&gt;Fontification&lt;/h3&gt;&lt;p&gt;In tree-sitter major modes, fontification is categorized into “features”, like “builtin”, “function”, “variable”, “operator”, etc. You can choose what “features” to enable for a mode. If you are feeling adventurous, it is also possible to add your own fontification rules.&lt;/p&gt;&lt;p&gt;To add/remove features for a major mode, use &lt;code&gt;treesit-font-lock-recompute-features&lt;/code&gt; in its mode hook. For example,&lt;/p&gt;&lt;pre class="code-block"&gt;(defun c-ts-mode-setup ()
  (treesit-font-lock-recompute-features
   '(function variable) '(definition)))

(add-hook 'c-ts-mode-hook #'c-ts-mode-setup)&lt;/pre&gt;&lt;p&gt;Features are grouped into decoration levels, right now there are 4 levels and the default level is 3. If you want to program in skittles, set &lt;code&gt;treesit-font-lock-level&lt;/code&gt; to 4 ;-)&lt;/p&gt;&lt;h3 id="Language%20grammars" class="subsection"&gt;Language grammars&lt;/h3&gt;&lt;p&gt;Tree-sitter major modes need corresponding langauge grammar to work. These grammars come in the form of dynamic libraries. Ideally the package manager will build them when building Emacs, like with any other dynamic libraries. But they can’t cover every language grammar out there, so you probably need to build them yourself from time to time. Emacs has a command for it: &lt;code&gt;treesit-install-language-grammar&lt;/code&gt;. It asks you for the Git repository and other stuff and builds the dynamic library. Third-party major modes can instruct their users to add the recipe for building a language grammar like this:&lt;/p&gt;&lt;pre class="code-block"&gt;(add-to-list
 'treesit-language-source-alist
 '(python "https://github.com/tree-sitter/tree-sitter-python.git"))&lt;/pre&gt;&lt;p&gt;Then typing &lt;code&gt;M-x treesit-install-language-grammar RET python&lt;/code&gt; builds the language grammar without user-input.&lt;/p&gt;&lt;h3 id="Other%20features" class="subsection"&gt;Other features&lt;/h3&gt;&lt;p&gt;Things like indentation, Imenu, navigation, etc, should just work.&lt;/p&gt;&lt;p&gt;There is no code-folding, selection expansion, and structural navigation (except for defun) in Emacs 29. Folding and expansion should be trivial to implement in existing third-party packages. Structural navigation needs careful design and nontrivial changes to existing commands (ie, more work). So not in 29, unfortunately.&lt;/p&gt;&lt;h2 id="Future%20plans" class="section"&gt;Future plans&lt;/h2&gt;&lt;h3 id="Navigation" class="subsection"&gt;Navigation&lt;/h3&gt;&lt;p&gt;The tree-sitter integration is far from complete. As mentioned earlier, structural navigation is still in the works. Right now Emacs allows you to define a “thing” by a regexp that matches node types, plus optionally a filter function that filters out nodes that matches the regexp but isn’t really the “thing”. Given the definition of a “thing”, Emacs has functions for finding the “things” around point (&lt;code&gt;treesit--things-around&lt;/code&gt;), finding the “thing” at point (&lt;code&gt;treesit--thing-at-point&lt;/code&gt;), and navigating around “things” (&lt;code&gt;treesit--navigate-thing&lt;/code&gt;). Besides moving around, these functions should be also useful for other things like folding blocks. Beware that, as the double dash suggests, these functions are experimental and could change.&lt;/p&gt;&lt;p&gt;I also have an idea for “abstract list elements”. Basically an abstract list element is anything repeatable in a grammar: defun, statement, arguments in argument list, etc. These things appear at every level of the grammar and seems like a very good unit for navigation.&lt;/p&gt;&lt;h3 id="Context%20extraction" class="subsection"&gt;Context extraction&lt;/h3&gt;&lt;p&gt;There is also potential for language-agnostic “context extraction” (for the lack of a better term) with tree-sitter. Right now we can get the name and span of the defun at point, but it doesn’t have to stop there, we can also get the parameter list, the type of the return value, the class/trait of the function, etc. Because it’s language agnostic, any tool using this feature will work on many languages all at once.&lt;/p&gt;&lt;p&gt;In fact, you can already extract useful things, to some degree, with the fontification queries written by major modes: using the query intended for the &lt;code&gt;variable&lt;/code&gt; query, I can get all the variable nodes in a given range.&lt;/p&gt;&lt;p&gt;There are some unanswered questions though: (1) What would be the best function interface and data structure for such a feature? Should it use a plist like &lt;code&gt;(:name ... :params ...)&lt;/code&gt;, or a cl-struct? (2) If a language is different enough from the “common pattern”, how useful does this feature remains? For example, there isn’t a clear parameter list in Haskell, and there could be several defun bodies that defines the same function. (3) Is this feature genuinely useful, or is it just something that looks cool? Only time and experiments can tell, I’m looking forward to see what people will do with tree-sitter in the wild :-)&lt;/p&gt;&lt;h3 id="Major%20mode%20fallback" class="subsection"&gt;Major mode fallback&lt;/h3&gt;&lt;p&gt;Right now there is no automatic falling back from tree-sitter major modes to “native” major modes when the tree-sitter library or language grammar is missing. Doing it right requires some change to the auto-mode facility. Hopefully we’ll see a good solution for it in Emacs 30. Right now, if you need automatic fallback, try something like this:&lt;/p&gt;&lt;pre class="code-block"&gt;(define-derived-mode python-auto-mode prog-mode "Python Auto"
  "Automatically decide which Python mode to use."
  (if (treesit-ready-p 'python t)
      (python-ts-mode)
    (python-mode)))&lt;/pre&gt;&lt;h3 id="Other%20plans" class="subsection"&gt;Other plans&lt;/h3&gt;&lt;p&gt;Existing tree-sitter major modes are pretty basic and doesn’t have many bells and whistles, and I’m sure there are rough corners here and there. Of course, these things will improve over time.&lt;/p&gt;&lt;p&gt;Tree-sitter is very different and very new, and touches many parts of Emacs, so no one has experience with it and no one knows exactly how should it look like. Emacs 29 will give us valuable experience and feedback, and we can make it better and better in the future.&lt;/p&gt;&lt;p&gt;If you are interested, get involved! Read &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-in-emacs-29/note/2020/contributing-to-emacs/index.html"&gt;Contributing to Emacs&lt;/a&gt; for some tips in getting involved with the Emacs development. Read &lt;a href="https://archive.casouri.cc/note/2023/tree-sitter-in-emacs-29/note/2023/tree-sitter-starter-guide/index.html"&gt;Tree-sitter Starter Guide&lt;/a&gt; if you want to write a major mode using tree-sitter. And of course, docstrings and the manual is always your friend. If you have questions, you can ask on Reddit, or comment in this post’s public inbox (see the footer).&lt;/p&gt;</content></entry>
  <entry><title>A prelude for writing Emacs dynamic modules</title><link href="https://archive.casouri.cc/note/2021/emacs-module-prelude"/><id>urn:uuid:b973fd64-5ad2-11ec-87a6-b729d55f528f</id><updated>2021-12-11T14:36:00.00-05:00</updated><content type="html">&lt;p&gt;When writing &lt;a id="footref:xeft" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Axeft"&gt;an Emacs dynamic module for Xapian&lt;sup class="inline-footref"&gt;1&lt;/sup&gt;&lt;/a&gt;, I found that calling Lisp functions in a dynamic module is painfully tedious. For example, the equivalent of&lt;/p&gt;&lt;pre class="code-block"&gt;(define-error 'xeft-error "Generic Xeft error" 'error)&lt;/pre&gt;&lt;p&gt;is&lt;/p&gt;&lt;pre class="code-block"&gt;emacs_value Qdefine_error = env-&amp;gt;intern (env, "define-error");
emacs_value Qxeft_error = env-&amp;gt;intern (env, "xeft-error");
emacs_value Qerror = env-&amp;gt;intern (env, "error");
char **text = "Generic Xeft error";
emacs_value message = env-&amp;gt;make_string (env, text , strlen (text));
emacs_value args[] = {Qxeft_error, message, Qerror};
int nargs = 3;
env-&amp;gt;funcall (env, Qdefine_error, nargs, args);&lt;/pre&gt;&lt;p&gt;Even though we usually only write a little Lisp for  defining the exposed functions and errors in a dynamic module, this is too much. Naturally I wrote some wrappers. With my wrappers, I can write the following instead:&lt;/p&gt;&lt;pre class="code-block"&gt;emp_funcall (env, "define-error", 3,
             emp_intern (env, "xeft-error"),
             emp_build_string (env, "Generic Xeft error"),
             emp_intern (env, "error"));&lt;/pre&gt;&lt;p&gt;I put these wrappers together into &lt;code&gt;emacs-module-prelude&lt;/code&gt;. Currently it provides these functions:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;emp_define_function&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;emp_funcall&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;emp_intern&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;emp_provide&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;emp_signal_message1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;emp_define_error&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;emp_nilp&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;emp_copy_string_contents&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;emp_build_string&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;You can find it at &lt;a href="https://archive.casouri.cc/note/2021/emacs-module-prelude/https:/github.com/casouri/emacs-module-prelude"&gt;&lt;em&gt;emacs-module-prelude&lt;/em&gt;&lt;/a&gt;. I can’t say that I’m a seasoned C programmer so use at your own risk. Corrections are very welcome.&lt;/p&gt;&lt;div id="footdef:xeft" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Axeft"&gt;1&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;For my note-searching package: &lt;a href="https://archive.casouri.cc/note/2021/emacs-module-prelude/https:/github.com/casouri/xeft"&gt;Xeft&lt;/a&gt;.&lt;/div&gt;&lt;/div&gt;</content></entry>
  <entry><title>Using Fontsets in Emacs</title><link href="https://archive.casouri.cc/note/2021/fontset"/><id>urn:uuid:336b8c2c-4d8b-11ec-967b-17e83717b0eb</id><updated>2021-11-24T17:01:00.00-05:00</updated><content type="html">&lt;h2 id="Fontset" class="section"&gt;Fontset?&lt;/h2&gt;&lt;p&gt;Fontset is a feature of Emacs that allows you to bundle together multiple fonts and use them as a single font, such that it covers more characters than a single font could have. For example, you can combine a Latin font, a Greek font and a Chinese font together.&lt;/p&gt;&lt;p&gt;With fontsets, we can use different Unicode fonts for different faces. For example, serif Latin and Chinese font for a “serif” face, and sans serif Latin and Chinese font for a “sans” face. Without fontsets, we can only set different Latin fonts to faces and use a single fall-back Chinese font.&lt;/p&gt;&lt;p&gt;&lt;img class="half" alt="A graph showing different fonts with different faces" src="https://archive.casouri.cc/note/2021/fontset/fonts%20&amp;amp;%20faces.svg"/&gt;&lt;/p&gt;&lt;h2 id="Create%20a%20fontset" class="section"&gt;Create a fontset&lt;/h2&gt;&lt;p&gt;A fontset is recognized by its name. Each fontset has two names, one short and one long. The short name looks like &lt;code&gt;fontset-xxx&lt;/code&gt;. The long name is a &lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/wiki.archlinux.org/title/X_Logical_Font_Description"&gt;X Logical Font Description&lt;/a&gt; with last two fields being &lt;code&gt;fontset&lt;/code&gt; and &lt;code&gt;xxx&lt;/code&gt;. For example,&lt;/p&gt;&lt;pre class="code-block"&gt;-*-ibm plex mono-medium-*-*-*-13-*-*-*-*-*-fontset-my fontset&lt;/pre&gt;&lt;p&gt;Emacs come with three fontsets by default: &lt;code&gt;fontset-startup&lt;/code&gt;, &lt;code&gt;fontset-standard&lt;/code&gt; and &lt;code&gt;fontset-default&lt;/code&gt;. We only care about &lt;code&gt;fontset-default&lt;/code&gt;; it is the ultimate fall-back when Emacs cannot find a font to display a character. But more on that later.&lt;/p&gt;&lt;p&gt;To create a fontset, you can use &lt;code&gt;create-fontset-from-fontset-spec&lt;/code&gt; and pass it a bunch of X Logical Font Descriptions, each for a font you want to include. I find that tedious. Instead, I like to create a fontset with a single ASCII font and use &lt;code&gt;set-fontset-font&lt;/code&gt; to add other fonts later, like this:&lt;/p&gt;&lt;pre class="code-block"&gt;(create-fontset-from-fontset-spec
 (font-xlfd-name
  (font-spec :family "IBM Plex Mono"
             :size 13
             :registry "fontset-my fontset")))&lt;/pre&gt;&lt;p&gt;Make sure you put the short fontset name under the &lt;code&gt;:registry&lt;/code&gt; spec. The code above creates the fontset, and returns its long name,&lt;/p&gt;&lt;pre class="code-block"&gt;-*-ibm plex mono-*-*-*-*-13-*-*-*-*-*-fontset-my fontset&lt;/pre&gt;&lt;p&gt;Now we can add a Chinese font and a Greek font:&lt;/p&gt;&lt;pre class="code-block"&gt;(set-fontset-font
 "fontset-my fontset"
 'han (font-spec :family "Source Han Serif" :size 12))
(set-fontset-font
 "fontset-my fontset"
 'greek (font-spec :family "Academica"))&lt;/pre&gt;&lt;p&gt;If you are not familiar with &lt;code&gt;set-fontset-font&lt;/code&gt;, &lt;a href="https://archive.casouri.cc/note/2021/fontset/http:/idiocy.org/emacs-fonts-and-fontsets.html"&gt;&lt;em&gt;Emacs, fonts and fontsets&lt;/em&gt;&lt;/a&gt; is a good read.&lt;/p&gt;&lt;h2 id="Apply%20a%20fonset" class="section"&gt;Apply a fonset&lt;/h2&gt;&lt;p&gt;Although the manual says we can use a fontset wherever a font is appropriate, it is not entirely true. If you pass your fontset through the &lt;code&gt;:font&lt;/code&gt; attribute in &lt;code&gt;set-face-attribute&lt;/code&gt;, &lt;a id="footref:takes-ascii" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Atakes-ascii"&gt;Emacs takes the ASCII font from the fontset and only uses the ASCII font for the face&lt;sup class="inline-footref"&gt;1&lt;/sup&gt;&lt;/a&gt;. The real way to do it is to use the undocumented &lt;code&gt;:fontset&lt;/code&gt; attribute:&lt;/p&gt;&lt;pre class="code-block"&gt;(set-face-attribute
 'some-face nil :fontset "fontset-my fontset")&lt;/pre&gt;&lt;p&gt;That’s not all. While the above code works for most faces, setting &lt;code&gt;:fontset&lt;/code&gt; for &lt;code&gt;default&lt;/code&gt; will not work as you expected, because Emacs again &lt;a id="footref:default" class="footref-anchor obviously-a-link" aria-label="Jump to footnote" href="#footdef%3Adefault"&gt;only takes the ASCII font, even if you use the &lt;code&gt;fontset&lt;/code&gt; attribute&lt;sup class="inline-footref"&gt;2&lt;/sup&gt;&lt;/a&gt;. So don’t set the fontset for the &lt;code&gt;default&lt;/code&gt; face; instead, just modify &lt;code&gt;fontset-default&lt;/code&gt; (it’s the ultimate fall-back fontset we mentioned earlier) for Unicode fonts, and use whatever method you like for ASCII font. If you read &lt;a href="https://archive.casouri.cc/note/2021/fontset/http:/idiocy.org/emacs-fonts-and-fontsets.html"&gt;&lt;em&gt;Emacs, fonts and fontsets&lt;/em&gt;&lt;/a&gt;, you’ll know we can modify &lt;code&gt;fontset-default&lt;/code&gt; by either&lt;/p&gt;&lt;pre class="code-block"&gt;(set-fontset-font "fontset-default" ...)&lt;/pre&gt;&lt;p&gt;or&lt;/p&gt;&lt;pre class="code-block"&gt;(set-fontset-font t ...)&lt;/pre&gt;&lt;p&gt;Technically you could set the &lt;code&gt;font&lt;/code&gt; attribute of a frame to a fontset by &lt;code&gt;set-frame-font&lt;/code&gt; and it works fine. But as soon as you change any font-related attributes in &lt;code&gt;default&lt;/code&gt; face, like font size, your fontset in the frame attribute will be overwritten by the font derived from &lt;code&gt;default&lt;/code&gt; face. So the best way is still to just modify &lt;code&gt;fontset-default&lt;/code&gt;.&lt;/p&gt;&lt;div id="footdef:takes-ascii" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Atakes-ascii"&gt;1&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;According to &lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/github.com/emacs-mirror/emacs/blob/11e5c7d8ca58cc946930048b5c88c8f582d4d5d8/src/xfaces.c#L3391"&gt;the source&lt;/a&gt;.&lt;/div&gt;&lt;/div&gt;&lt;div id="footdef:default" class="footdef"&gt;&lt;div class="def-footref obviously-a-link"&gt;&lt;a aria-label="Jump back to main text" href="#footref%3Adefault"&gt;2&lt;/a&gt;&lt;/div&gt;&lt;div class="def-footdef"&gt;Basically, if the face is &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;set-face-attribute&lt;/code&gt; calls &lt;code&gt;set_font_frame_param&lt;/code&gt; (&lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/github.com/emacs-mirror/emacs/blob/11e5c7d8ca58cc946930048b5c88c8f582d4d5d8/src/xfaces.c#L3514"&gt;source&lt;/a&gt;), which only looks at the &lt;code&gt;:font&lt;/code&gt; attribute (&lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/github.com/emacs-mirror/emacs/blob/11e5c7d8ca58cc946930048b5c88c8f582d4d5d8/src/xfaces.c#L3685"&gt;source&lt;/a&gt;).&lt;/div&gt;&lt;/div&gt;&lt;h2 id="Further%20reading" class="section"&gt;Further reading&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Command &lt;code&gt;list-fontsets&lt;/code&gt; lists all the defined fontsets.&lt;/li&gt;&lt;li&gt;Command &lt;code&gt;describe-fontset&lt;/code&gt; shows which font is each character assigned to in a fontset.&lt;/li&gt;&lt;li&gt;Manual page: &lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/www.gnu.org/software/emacs/manual/html_node/emacs/Fontsets.html"&gt;&lt;em&gt;Fontsets, Emacs User Manual&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Another manual page: &lt;a href="https://archive.casouri.cc/note/2021/fontset/https:/www.gnu.org/software/emacs/manual/html_node/elisp/Fontsets.html"&gt;&lt;em&gt;Fontsets, Emacs Lisp Manual&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry>
</feed>
